- 关于两种压测模型（并发数模型、RPS模型）的一些讨论
	- Gatling的相关文档：
	  https://gatling.io/docs/gatling/reference/current/core/injection/?
	  https://gatling.io/2018/10/gatling-3-closed-workload-model-support/
	- K6的文档
	  https://k6.io/docs/using-k6/scenarios/arrival-rate/
	- 阿里PTS的看法
	  https://segmentfault.com/a/1190000019832726
	- Locust社区的讨论
	  https://github.com/locustio/locust/issues/646
	- 学术界对于这两种模型的看法（Closed Model、Open Model的源头也是来自学术界）
	  https://www.usenix.org/legacy/event/nsdi06/tech/full_papers/schroeder/schroeder.pdf
-
- Java协程当前生态
	- kotlin（一种JVM语言，原理为修改字节码。需要改语言，有学习成本）
	- loom（未来JVM特性，暂未正式发布）
	- quasar（原理为修改字节码，目前该开源项目已不再维护）
	- wisp（阿里对JVM二次开发，原生thread语义，可由配置JVM参数生效，无需改代码）
		- 由于基于原生thread语义，在内存占用上没做优化，占用内存与线程占用内存等同，这块对单机协程数的上限有一定影响
-
- 总共5个层面，从总体战略到单兵的战术（from taowen）
	- 0、选择有价值的需求。这个是根本，后面怎么做都得是需求先有价值
		- 0.5，如何判断有一个需求是有价值的，这个可以 scalable 的量化手段是什么
			- 产品层面如何判断一个是把一个 0.5 的功能做到 0.6 还是把一个 1.0 的做到 1.2，怎么样才是眼下最有价值的工作
			- 还有产品经理该如何分工
				- 产品和研发要编组么？这样再不靠谱（烂）的 idea 都能做出来看看
				- 不编组的话，产品摸鱼太容易，是否能接受？
		- 0.7， 这个需求是一个新的大功能，还是一个旧的功能的扩展，还是一个option，甚至是一个 plugin？这个很多时候模棱两可，如何有一个可持续 work的判断方法
	- 1、需求是复用已有产品，重新写，还是复制一份再修改
	- 2、产品经理来设计产品，怎么样堆砌功能才能减缓变臃肿的速度，以及尽可能保持一致
	- 3、产品开发团队把产品设计给实现出来
	- 4、单个开发者在其他人的基础上实现自己被分配的任务
- 针对以上5个层面，值得推广的想法
	- 1.1 未必复用就是好的。复制一份再修改也有适合的场合。
		- 不能因为反正也是要再修改的，怎么也不可能“零代码”，或者“零成本”了，就完全认为这是没有价值的。
		- 零代码SaaS有适合对象，但未必适合所有需求。
		- 带版本号的 library 通过 package manager 分发，或者在线提供服务的 SaaS 都默认了跟着升级是好事情。然而不一定所有的代码都需要“跟着升级”。
		- 复制一份然后不跟着升级也未必就不好。
	- 2.1 功能不应该是增不删的，
		- 如果每个功能都“可删除”会带来什么？
		- 为什么一个需求总是单向地说要在哪里增加什么？
		- MVP 为什么只是一开始的创业产品，而不能是被一直保持下去成为一个可选项呢？
		- 参见 https://courses.cs.washington.edu/courses/cse503/08wi/parnas-1979.pdf
	- 2.2 产品设计尽可能保持一致需要从实现层面提供反向的反馈。
		- 设计风格是不是尽可能统一，列表详情编辑等中后台产品设计是不是尽可能统一，统计报表是不是尽可能统一，可以在源代码层面进行量化。
		- “不一致”引入的成本如果不能被量化，就没法推动一致性。
	- 3.1 提高团队的 autonomy，减少团队配合中因为额外沟通需要支付的额外成本，少开点会多干点活。
		- 如果react能支持需求，就别一个产品里同时用react和vue。
		- 如果一个人有能力把需求实现出来，就不要因为这个人没有后端开发的头衔，就要求专门搞个人只做后端开发。
	- 3.2 不仅仅开发团队应该少开点会，运行时的微服务也不应该 chatty。
		- 在网络抖动的时候，挂掉的功能要越少越好，受影响的客户要越少越好。
		- 发布过程中，灰度的步子越小越好，要完全避免一发布全挂的问题。
		- 数据库的分库分表不应该事后打补丁，任何功能开发的时候就要知道sharding应该怎么弄。
		- 尽可能把运行时按照单元化set化的原则去切分。
		- 这就需要把依赖从同步的转成异步的，高频的转成低频的，不可降级的变成产品上有降级方案的。
	- 4.1 每个开发者应该能用“把代码跑起来”的方式去理解已有的代码。
		- 代码跑起来之后不应该是完全不可视的黑盒，应该能够知其然也知其所以然。
		- 更多的代码应该是 functional core 的模式来编写，而 imperative shell 的部分应该最小化，从而更容易“把代码跑起来”。
		- 执行过程应该尽可能多的在受控的运行时环境里，从而对于执行过程能够尽可能的白盒化，observability 应该尽可能标准而且易于获得。
	- 4.2 每个开发者应该能很容易找到自己关心的代码，只阅读自己关心的代码。
		- 应该尽可能地用静态组合代替动态组合，不能因为要出现在同一个页面上，就一定写一起。
		- 不能因为要在同一个50ms内被同时执行到，就要写一个函数内。
		- 代码的静态组织要首先服务于可阅读性。
		- 我们倾向于如何用产品文档，用自然语言来描述一个需求，那么对应的源代码其叙事风格应该是类似的。
			- 因为总有一天，产品文档会散佚，而源代码总是最后一个消失的东西。