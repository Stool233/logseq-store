- coredump没生成的原因
	- 这篇文章很详细：https://fromdual.com/hunting-the-core
	- 摘录check list在这里
		- The core would have been larger than the current limit.
		- You don't have the necessary permissions to dump core (directory and file). Notice that core dumps are placed in the dumping process' current directory which could be different from the parent process.
		- Verify that the file system is writeable and have sufficient free space.
		- If a sub directory named core exist in the working directory no core will be dumped.
		- If a file named core already exist but has multiple hard links the kernel will not dump core.
		- Verify the permissions on the executable, if the executable has the suid or sgid bit enabled core dumps will by default be disabled. The same will be the case if you have execute permissions but no read permissions on the file.
		- Verify that the process has not changed working directory, core size limit, or dumpable flag.
		- Some kernel versions cannot dump processes with shared address space (AKA threads). Newer kernel versions can dump such processes but will append the pid to the file name.
		- The executable could be in a non-standard format not supporting core dumps. Each executable format must implement a core dump routine.
		- The segmentation fault could actually be a kernel Oops, check the system logs for any Oops messages.
		- The application called exit() instead of using the core dump handler.
	- 最后一点application call exit，有遇到一个SIGPIPE信号问题
		- https://developer.aliyun.com/article/42215
		- https://blog.csdn.net/qq_40860852/article/details/104855253
		- 民间描述： 对一个对端已经关闭的 socket 调用两次 write，第二次 write 将会生成 SIGPIPE 信号，该信号默认结束进程。
		- 产生 SIGPIPE 的条件
			- 对一个已经收到 FIN 包的 socket 调用 read 方法，如果接收缓冲已空，则返回 0，这就是常说的“连接关闭”表示。
			- 对一个已经收到 FIN 包的 socket 第一次调用 write 方法时，如果发送缓冲没问题，则 write 调用会返回写入的数据量，同时进行数据发送。但是发送出去的报文会导致对端发回 RST 报文。因为对端的 socket 已经调用了 close 进行了完全关闭，已经处于既不发送，也不接收数据的状态。所以第二次调用 write 方法时（假设在收到 RST 之后）会生成 SIGPIPE 信号，导致进程退出（这就是为什么第二次 write 才能触发 SIGPIPE 的原因）。
			-