# Refactoring Invariants（重构不变量）
	- https://buttondown.com/hillelwayne/archive/refactoring-invariants/
	- 一个[[TLA+]]特性
		- ```
		  RefactorProp ==
		      [][Foo <=> NewFoo]_vars
		  ```
			- 它所要表达的只是：每个“ `Foo` ”步骤也必须是一个“ `NewFoo` ”步骤。如果重构操作与原始操作的行为有所不同，模型检查器将报告它未能通过的行为和过渡。相反，如果模型检查器通过了，我就可以安全地假设它们具有相同的行为。
	- 这是**refactoring invariant（重构不变量）**
		- Well technically it's an *action property* since it's on the transitions of states, not the states, but "refactor invariant" gets the idea across better.
			- 从技术上讲，这是一个动作属性，因为它是在状态转换上，而不是在状态上，但“重构不变量”更能准确地传达这个概念。
	- 函数的旧版本和新版本具有相同的行为。 重构不变量在形式化规格说明中非常有用。 软件开发人员花在重构上的时间已经足够多了，它们对于编写代码也很有用。
	- 可惜的是，在代码中表达不变式要困难一些。
		- 在TLA中，我们处理的是有限状态空间，因此模型检查器可以对每个可能的状态进行检查。
		- 即使是一个简单的程序，也可以通过无限多个可能的函数输入拥有不可枚举的状态空间。
	- (Also formal specifications are "pure" simulations while programs have side effects.)
		- (正式的 规格说明 是“纯粹的”模拟，而程序则具有副作用。)
	- 通常验证程序重构的方法是从一个庞大的测试套件开始。
		- 这应该可以通过失败的测试捕捉到一个有问题的重构。
			- 但缺点是，你可能根本就没有测试套件，或者没有覆盖你特定重构的测试套件。
		- 其次，即使有测试套件，它也只是间接地测试不变式。
			- 它只是在测试其他内容时捕捉到了重构错误。
	- 如果我们想直接测试重构不变式呢？
		- **有以下两种方法可以实现这一点：**
			- 一：是引入形式化方法。
				- 雷·迈尔斯有一段关于正式证明代码重构是否正确的精妙视频。这段视频使用的是小众语言ACL2，但他也有关于重构C代码的视频。你可能不需要证明重构是否正确，可能只需使用SMT求解器找出反例即可。
			- 二：通过使用[[基于属性的测试]]。
				- 生成随机输入，将它们传递给两个函数，并检查输出是否相同。
					- One tricky bit is if the function is part of a long call chain `A -> B -> C`, and you want to test that refactoring `C'` doesn't change the behavior of `A`. You'd have to add a `B'` that uses `C'` and then an `A'` that uses `B'`. Maybe you could instead create a branch, commit the change the `C'` in that branch, and then run a [cross-branch test](https://www.hillelwayne.com/post/cross-branch-testing/) against each branch's `A`.
					- Impure functions are harder. The test now makes some side effect twice, which could spuriously break the refactoring invariant. You could instead test the changes are the same, or try to get the functions to effect different entities and then compare the updates of each entity. There's no general solution here though, and there might be No Good Way for a particular effectful refactoring.
	- ### Behavior-changing rewrites（**行为改变重写**）
		- We can apply similar ideas for rewrites that change *behavior*.
			- Say we have an API, and v1 returns a list of user names while v2 returns a `{version, userids}` dict. Then we can find some transformation of v2 into v1, and run the refactoring invariant on that:
				- ```python
				  def v2_to_v1(v2_resp):
				      return [User(id).name for user in v2_resp["userids"]]
				  
				  @given(some_query_generator)
				  def test_refactoring(q):
				      assert v1(q) == v2_to_v1(v2(q))
				  ```
		- Fun fact: `v2_to_v1` is a [software homomorphism](https://buttondown.com/hillelwayne/archive/software-isomorphisms/)!
			- 有趣的事实： `v2_to_v1` 是一个软件同构体！
		-