# Refactoring Invariants（重构不变量）
	- https://buttondown.com/hillelwayne/archive/refactoring-invariants/
	- 一个[[TLA+]]特性
		- ```
		  RefactorProp ==
		      [][Foo <=> NewFoo]_vars
		  ```
			- 它所要表达的只是：每个“ `Foo` ”步骤也必须是一个“ `NewFoo` ”步骤。如果重构操作与原始操作的行为有所不同，模型检查器将报告它未能通过的行为和过渡。相反，如果模型检查器通过了，我就可以安全地假设它们具有相同的行为。
	- 这是**refactoring invariant（重构不变量）**
		- Well technically it's an *action property* since it's on the transitions of states, not the states, but "refactor invariant" gets the idea across better.
			- 从技术上讲，这是一个动作属性，因为它是在状态转换上，而不是在状态上，但“重构不变量”更能准确地传达这个概念。
	- 函数的旧版本和新版本具有相同的行为。 重构不变量在形式化规格说明中非常有用。 软件开发人员花在重构上的时间已经足够多了，它们对于编写代码也很有用。
	- 可惜的是，在代码中表达不变式要困难一些。
		- 在TLA中，我们处理的是有限状态空间，因此模型检查器可以对每个可能的状态进行检查。
		- 即使是一个简单的程序，也可以通过无限多个可能的函数输入拥有不可枚举的状态空间。
-