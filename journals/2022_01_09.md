- 内存问题 一些总结
	- 总结主要涉及三个方面
		- 知识/信息
		- 验证知识/信息 是否真实的策略
		- 一些常用的、帮助快速验证的工具
	- 虚拟内存与物理内存
		- 问题
			- 内存很宝贵，给操作系统上每个进程直接分配物理内存，资源占用较大。（目前一般服务器的内存可以做得很大，该问题相对不严重）
			- 一个进程有可能不小心写了另一个进程的内存，安全如何得到保障。
		- 故有了虚拟内存，解决了多个进程如何安全、高效访问同一个物理内存的问题。
			- 虚拟内存的出现对内存使用做好了隔离，每个进程拥有独立的、连续的、统一的虚拟地址空间
			- 虚拟内存使得操作系统可以给进程分配超过当前所剩物理内存的内存，通过磁盘与内存来回传送数据的方式，物理内存只保存活动区域。
	- Linux 四级页表
	  id:: 61dacb70-e9fa-4719-b6df-21f552b558c6
		- 为了减少虚拟内存映射表的内存占用，很多操作系统使用多级页表的方式节省内存。
			- 这种多级结构的方式使得没有使用的内存不用分配页表项。
		- 【如何验证虚拟内存所对应的物理内存？】
			- 可以用内核扩展模块等方式获取。
	- 进程的内存布局
		- linux 上的可执行文件的格式是 elf
			- elf 是一个静态文件，这个静态文件由不同的分节组成，我们这里叫它 section，在运行时，部分跟运行时相关的 Section 会被映射到进程的虚拟地址空间中，比如图中的代码段和数据段。
			- 除了这部分静态的区域，进程启动以后还有大量动态内存消耗区，比如栈、堆、mmap 区。
			- ![image.png](../assets/image_1641729134697_0.png){:height 341, :width 145}
			-
			- 【如何查看进程内存瓜分情况】
				- 可以用pmap来确认
	- libc 内存管理原理探究
		- ![image.png](../assets/image_1641729235905_0.png){:height 278, :width 312}
		- ![image.png](../assets/image_1641729255682_0.png){:height 247, :width 424}
		- 为什么有了这些系统调用，还需要 libc 再封装一层呢？
			- 一个主要原因因为系统调用很昂贵，而内存的申请释放又特别频繁，所以 libc 采取的的方式就是批量申请，然后作为内存的黄牛二道贩子，慢慢零售给后面的应用程序。
			- 第二个原因是为了编程上的统一，比如有些时候用 brk，有些时候用 mmap，不太友好，brk 在多线程下还需要进行加锁，用一个 malloc 就很香。
	- Linux 内存分配器
		- ![image.png](../assets/image_1641729327370_0.png)
		- 这些内存分配器致力于解决两个问题：多线程下锁的粒度问题，是全局锁，还是局部锁还是无锁。第二个问题是小内存回收和内存碎片问题，比如 jemalloc 在内存碎片上有显著的优势。