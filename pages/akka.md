- Actor 模型如何满足现代分布式系统的需求？
	- Actor 模型抽象允许你从通信的角度来考虑你的代码
		- 在不使用锁的情况下强制封装。
		- 利用协同实体对信号作出反应、改变状态、相互发送信号的模型来驱动整个应用程序向前发展。
		- 不要担心执行机制与我们的世界观（world view）不匹配。
	- 消息传递的使用避免了锁和阻塞
		- Actor 不调用方法，而是互相发送消息。
			- 发送消息不会将线程的执行权从发送方传输到目标方。
			- Actor 可以发送一条消息并继续其他操作，而不是阻塞。
				- 因此，它可以在相同的时间内完成更多的工作。
		- 对于对象，当一个方法返回时，它释放对其执行线程的控制。
			- 在这方面，Actor 的行为非常类似于对象，它们对消息作出反应，并在完成当前消息的处理后执行返回。
			- 通过这种方式，Actor 实际上实现了我们设想中对象的执行方式：
				- ![image.png](../assets/image_1649561328011_0.png)
		- 传递消息和调用方法之间的一个重要区别是消息没有返回值。
			- 通过发送消息，Actor 将工作委托给另一个 Actor。 正如我们在「调用栈的假象」中看到的，如果它期望返回值，那么发送 Actor 要么阻塞，要么在同一线程上执行另一个 Actor 的工作。 相反，接收 Actor 在回复消息中传递结果。
		- 我们模型中需要的第二个关键改变是恢复封装。
			- Actor 对消息的反应就像对象对调用它们的方法“反应”一样。
			- 不同之处在于，不同于多个线程“突出（protruding）”到 Actor 中并对内部状态和不变量造成严重破坏，Actor 的执行动作独立于消息的发送者，并对传入消息依次作出反应，一次一个。
			- 当每个 Actor 按顺序处理发送给它的消息时，不同的 Actor 同时工作，以便 Actor 系统可以同时处理硬件所支持的尽可能多的消息。
			- 由于每个 Actor 最多只能同时处理一条消息，因此可以不同步地保留 Actor 的不变量。这是自动发生的，不使用锁：
				- ![image.png](../assets/image_1649561580102_0.png)
		- 总之，当 Actor 收到消息时会发生以下情况：
			-
			-
		-
	-