- React 哲学
  collapsed:: true
	- 步骤一：将 UI 拆解为组件层级结构
		- 一开始，在绘制原型中的每个组件和子组件周围绘制盒子并命名它们。
	- 步骤二：使用 React 构建一个静态版本
		- 现在你已经拥有了你自己的组件层级结构，是时候实现你的应用程序了。
		- 最直接的办法是根据你的数据模型，构建一个不带任何交互的 UI 渲染代码版本…经常是先构建一个静态版本比较简单，然后再一个个添加交互。
			- 构建一个静态版本需要写大量的代码，并不需要什么思考;
			- 但添加交互需要大量的思考，却不需要大量的代码。
		- 构建应用程序的静态版本来渲染你的数据模型，
			- 将构建 [组件](https://zh-hans.react.dev/learn/your-first-component) 并复用其它的组件，
			- 然后使用 [props](https://zh-hans.react.dev/learn/passing-props-to-a-component) 进行传递数据。
				- Props 是从父组件向子组件传递数据的一种方式。
				- 如果你对 [state](https://zh-hans.react.dev/learn/state-a-components-memory) 章节很熟悉，不要在静态版本中使用 state 进行构建。
					- state 只是为交互提供的保留功能，即数据会随着时间变化。
					- 因为这是一个静态应用程序，所以并不需要。
			- 你既可以通过从层次结构更高层组件（如 `FilterableProductTable`）开始“自上而下”构建，也可以通过从更低层级组件（如 `ProductRow`）“自下而上”进行构建。
				- 在简单的例子中，自上而下构建通常更简单；
				- 而在大型项目中，自下而上构建更简单。
	- 步骤三：找出 UI 精简且完整的 state 表示
		- 为了使 UI 可交互，你需要用户更改潜在的数据结构。你将可以使用 **state** 进行实现。
		- 考虑将 state 作为应用程序需要记住改变数据的最小集合。
			- 组织 state 最重要的一条原则是保持它 [DRY（不要自我重复）](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)。
				- 计算出你应用程序需要的绝对精简 state 表示，按需计算其它一切。
		- 其中哪些是 state 呢？标记出那些不是的:
			- 随着时间推移 **保持不变**？如此，便不是 state。
			- 通过 props **从父组件传递**？如此，便不是 state。
			- 是否可以基于已存在于组件中的 state 或者 props **进行计算**？如此，它肯定不是state！
	- 步骤四：验证 state 应该被放置在哪里
		- 在验证你应用程序中的最小 state 数据之后，你需要验证哪个组件是通过改变 state 实现可响应的，或者 **拥有** 这个 state。
			- 记住：React 使用单向数据流，通过组件层级结构从父组件传递数据至子组件。
		- 为你应用程序中的每一个 state:
			- 1. 验证每一个基于特定 state 渲染的组件。
			- 2. 寻找它们最近并且共同的父组件——在层级结构中，一个凌驾于它们所有组件之上的组件。
			- 3. 决定 state 应该被放置于哪里:
				- 1. 通常情况下，你可以直接放置 state 于它们共同的父组件。
				- 2. 你也可以将 state 放置于它们父组件上层的组件。
				- 3. 如果你找不到一个合适来放这个 state 的地方，单独创建一个新的组件去管理这个 state，并将它添加到它们父组件上层的某个地方。
		- 用 [`useState()` Hook](https://zh-hans.react.dev/reference/react/useState) 为组件添加 state。
			- Hook 可以“钩住”组件的 [渲染周期](https://zh-hans.react.dev/learn/render-and-commit)。
	- 步骤五：添加反向数据流
		- 目前你的应用程序可以带着 props 和 state 随着层级结构进行渲染。但是为了支持通过用户输入来改变 state，你需要让数据反向传输。
			- React 使数据流变得明确，但比双向数据绑定需要多写一些代码。
		-
	-
- Reducer和Context
	- 迁移状态逻辑至 Reducer 中
		- 对于那些需要更新多个状态的组件来说，过于分散的事件处理程序可能会令人不知所措。
		- 对于这种情况，你可以在组件外部将所有状态更新逻辑合并到一个称为 “reducer” 的函数中。
			- 这样，事件处理程序就会变得简洁，因为它们只需要指定用户的 “actions”。
		- **Reducer**，本质上是一个函数，负责根据“动作（action）”来集中处理**所有状态的变化逻辑**。
			- 通常配合 `useReducer` 钩子使用。
			- Reducer 会接收当前状态和 action，然后返回新的状态。
			- 这种模式让**复杂状态管理逻辑集中、清晰、可维护**。
		- 为什么要迁移到 Reducer？
			- **集中管理逻辑**：所有状态的变化都在 reducer 中描述，避免了逻辑分散在各个 handler 里。
			- **易于维护和扩展**：当状态逻辑变复杂时，只需修改 reducer。
			- **便于调试**：所有状态变更都有明确的 action 类型，易于追踪。
	- 使用 Context 深层传递参数
		- 通常，你会通过 props 将信息从父组件传递给子组件。
		- 但是，如果要在组件树中深入传递一些 prop，或者树里的许多组件需要使用相同的 prop，那么传递 prop 可能会变得很麻烦。
		- Context 允许父组件将一些信息提供给它下层的任何组件，不管该组件多深层也无需通过 props 逐层透传。
			- **Context** 可以解决“**深层组件需要用到同样的数据**”的问题。
				- *Context* 允许你**不通过 props**，就能让某个数据从父组件“广播”到所有后代组件。
				- 这样，**中间层组件不需要再负责转传数据**，只有需要用的组件才“订阅”这个数据。
			-
-