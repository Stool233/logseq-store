### 什么是算法的时间复杂度
	- 时间复杂度是衡量一个算法运行效率的一种方式。它表示算法在输入规模（通常用 \( n \) 表示）增加时，所需要的时间资源的增长速率。通常我们使用[[大O]]符号（Big O notation）来表示时间复杂度。
- ### 大O符号
	- 大O符号 \( O(f(n)) \) 用来描述算法的运行时间的上界。它忽略常数和低阶项，关注输入规模 \( n \) 趋近无穷时的增长趋势。例如，时间复杂度为 \( O(n^2) \) 的算法在大多数情况下比时间复杂度为 \( O(n) \) 的算法运行得慢，但具体的性能还取决于输入规模和常数因子。
- ### 常见的时间复杂度
	- **常数时间 \( O(1) \)**：算法的运行时间不随输入规模的变化而变化。例如，访问数组中某个元素的操作。
	- **对数时间 \( O(\log n) \)**：算法的运行时间随输入规模的对数变化。例如，二分查找算法。
	- **线性时间 \( O(n) \)**：算法的运行时间与输入规模成正比。例如，遍历一个数组。
	- **线性对数时间 \( O(n \log n) \)**：比线性时间稍慢，但比二次时间快。例如，快速排序和归并排序的平均时间复杂度。
	- **二次时间 \( O(n^2) \)**：算法的运行时间与输入规模的平方成正比。例如，简单的排序算法如冒泡排序、选择排序和插入排序的最坏情况时间复杂度。
	- **指数时间 \( O(2^n) \)**：算法的运行时间随着输入规模的指数增长。例如，解决旅行商问题（TSP）的暴力搜索算法。
	- **阶乘时间 \( O(n!) \)**：算法的运行时间随着输入规模的阶乘增长。例如，用暴力搜索解决组合问题。
- ### 如何分析时间复杂度
	- 1. **找出基本操作**：确定算法中最频繁执行的操作。
	- 2. **计算基本操作的执行次数**：分析该基本操作在最坏情况下的执行次数。
	- 3. **忽略常数项和低阶项**：用大O符号表示复杂度，忽略常数系数和低阶项。
- ### 例子
	- #### 线性搜索
	  ```python
	  def linear_search(arr, target):
	    for i in range(len(arr)):
	        if arr[i] == target:
	            return i
	    return -1
	  ```
	  这个算法的时间复杂度是 \( O(n) \)，因为在最坏情况下，需要遍历整个数组。
	- #### 二分查找
	  ```python
	  def binary_search(arr, target):
	    low = 0
	    high = len(arr) - 1
	    while low <= high:
	        mid = (low + high) // 2
	        if arr[mid] == target:
	            return mid
	        elif arr[mid] < target:
	            low = mid + 1
	        else:
	            high = mid - 1
	    return -1
	  ```
	  这个算法的时间复杂度是 \( O(\log n) \)，因为每次查找操作将搜索范围减半。
- ### 总结
	- 时间复杂度是评价算法效率的重要工具。理解和分析算法的时间复杂度可以帮助我们选择和设计更高效的算法，从而提升程序的性能。
-