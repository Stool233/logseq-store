- mac下的汇编
	- 来源：
		- https://github.com/Evian-Zhang/Assembly-on-macOS
	- Mach-O文件结构
		- 在macOS上的可执行文件，都是Mach-O格式的文件
		- 关于Mach-O文件，详细可参考Apple官方文档[Mach-O Programming Topics](https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/MachOTopics/0-Introduction/introduction.html). 这里我们只是简单介绍一下。
			- ![image.png](../assets/image_1692539618318_0.png){:height 489, :width 431}
		- Mach-O文件由头(Header)、装载指令(Load commands)和数据(Data)组成。
			- 我们可以通过[MachOView](https://github.com/fangshufeng/MachOView)软件进行查看。
		- 其中，最重要的组成部分就是Data.
			- 我们可以从图中看到，Data可以分为多个段(Segment), 每个段又可以分为多个节(Section).
			- 从逻辑角度来看，每个段内的节存储的数据都有类似的目的。
			- 如`__TEXT`段内存储的有汇编源代码、字符串等，`__DATA`段内存储非常量初始化变量等。
			- 从内存管理角度来看，每个段的大小被要求是页大小的倍数，也就是4096B的倍数。
			- 当程序加载时，就可以正好将一个段加载到一个页内。
- 栈
	- 当程序运行时，系统会自动给这个进程分配一个栈。这里的栈的数据结构就是数据结构中所说的栈，也就是先进后出的线性表。在x86-64架构下，栈是向下生长的。也就是说，每向栈中`PUSH`一个数据，栈顶的指针就会向逻辑地址减小的方向移动。
- ASLR
	- 从Mac OS X 10.5开始，Apple引入了地址空间配置随机加载(ASLR)机制。在每次程序执行的过程中，程序在内存中的开始地址，堆、栈、库的地址都会随机化，这样可以更好地保护不受攻击者攻击。
- PIE
	- 在ASLR中我们可以看到，大部分变量在每次运行时的逻辑地址都不一样。那么，我们在汇编层面访问这些变量时，就不能直接访问一个固定的逻辑地址。
	- 因此，我们在汇编语言中有许多技巧可以生成位置无关代码(Position Independent Code, PIC).
		- 这些代码中没有一处会直接访问固定的逻辑地址。
		- 由位置无关代码编译生成的可执行文件称为位置无关可执行文件(Position Independent Executable, PIE).
		- 在我们在macOS上的汇编语言学习过程中，大多数编写的都是PIC.
- 汇编器指令(Directive)
	- .section
		- mach-o可执行文件的Data部分拥有许多段(Segment), 每个段又有许多节(section). 同一个段的作用往往是类似的，同时在执行的时候一个段会被分配到一个页之中
		- 而.section最常用的格式，就是
			- .section    segname, sectname
		- 在macho中，纯代码被放在了__TEXT段的__text节中，因此，我们在文件的第二行写了
			- .section    __TEXT, __text
			- 代表之后的语句都是__TEXT段的__text节中。
	- .globl
		- 我们在由汇编语言翻译机器码的时候，得到的文件并不仅仅包含操作的指令，还需要包含一些名字和记号。比如说，C语言中，程序执行的起点是main函数。那么，这个函数的名字main就要包含在文件中，使得程序执行的时候知道执行哪个函数。
-
- .equ定义字面量
	- 类似C语言中的\#define 定义的宏
-
- 局部变量
	- 栈
		- 在操作系统基础中，我们谈到，在一个程序运行的时候，系统会自动给这个程序分配一个栈区。这个栈区和数据结构中所说的栈类似，也支持压栈和弹栈的操作。栈区在逻辑地址空间里是一块连续的空间，栈底是固定的，每次压栈，都会使栈顶向逻辑地址减小的方向移动。
		- rsp寄存器。从它的名字就可以看出来，stack pointer, 它存储的值永远是栈顶的地址，所以它又被叫做栈顶指针。
			- 我们可以用(%rsp)来获取栈顶存储的值，
			- 通过a(%rsp), 其中a是任何一个整数，来获取地址是rsp存储的值加a处的内存单元的值。
				- 比如说，2(%rsp)就是栈顶上方（逻辑地址增大方向）2个字节处的值，
				- -2(%rsp)就是栈顶下方（逻辑地址减小方向）2个字节处的值。
		- 在汇编语言中，压栈和弹栈的助记符分别是push和pop.
			- 这两个操作均有一个操作数。
			- push的操作是将栈顶指针向下移动（也就是将rsp内的值减小），并将移动后rsp对应位置内存区域的值赋为其操作数，而pop则相反。
			- 这里“向下移动”的距离是根据push后面跟着的字母决定的，如pushq就是把rsp内的值减8.
		- 此外，如果是想获得栈顶的值，而不弹栈，可以直接用mov来实现。
			- 如popq   %rax是将栈顶的8个字节内存储的值赋给rax, 并且栈顶指针向上移动8个字节。
			- 而movq   (%rsp), %rax则是只将栈顶的8个字节内存储的值赋给rax, 不涉及栈顶指针的移动。
			- 而如果只想弹栈却不想赋值，那么直接对rsp进行add即可。
				- 如想把栈顶的8个字节的数据弹栈，就直接addq $8, %rsp.
		-
-