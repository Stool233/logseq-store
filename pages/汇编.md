- mac下的汇编
	- 来源：
		- https://github.com/Evian-Zhang/Assembly-on-macOS
	- Mach-O文件结构
		- 在macOS上的可执行文件，都是Mach-O格式的文件
		- 关于Mach-O文件，详细可参考Apple官方文档[Mach-O Programming Topics](https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/MachOTopics/0-Introduction/introduction.html). 这里我们只是简单介绍一下。
			- ![image.png](../assets/image_1692539618318_0.png){:height 489, :width 431}
		- Mach-O文件由头(Header)、装载指令(Load commands)和数据(Data)组成。
			- 我们可以通过[MachOView](https://github.com/fangshufeng/MachOView)软件进行查看。
		- 其中，最重要的组成部分就是Data.
			- 我们可以从图中看到，Data可以分为多个段(Segment), 每个段又可以分为多个节(Section).
			- 从逻辑角度来看，每个段内的节存储的数据都有类似的目的。
			- 如`__TEXT`段内存储的有汇编源代码、字符串等，`__DATA`段内存储非常量初始化变量等。
			- 从内存管理角度来看，每个段的大小被要求是页大小的倍数，也就是4096B的倍数。
			- 当程序加载时，就可以正好将一个段加载到一个页内。
	- 栈
		- 当程序运行时，系统会自动给这个进程分配一个栈。这里的栈的数据结构就是数据结构中所说的栈，也就是先进后出的线性表。在x86-64架构下，栈是向下生长的。也就是说，每向栈中`PUSH`一个数据，栈顶的指针就会向逻辑地址减小的方向移动。
	- ASLR
		- 从Mac OS X 10.5开始，Apple引入了地址空间配置随机加载(ASLR)机制。在每次程序执行的过程中，程序在内存中的开始地址，堆、栈、库的地址都会随机化，这样可以更好地保护不受攻击者攻击。
	- PIE
		- 在ASLR中我们可以看到，大部分变量在每次运行时的逻辑地址都不一样。那么，我们在汇编层面访问这些变量时，就不能直接访问一个固定的逻辑地址。
		- 因此，我们在汇编语言中有许多技巧可以生成位置无关代码(Position Independent Code, PIC).
			- 这些代码中没有一处会直接访问固定的逻辑地址。
			- 由位置无关代码编译生成的可执行文件称为位置无关可执行文件(Position Independent Executable, PIE).
			- 在我们在macOS上的汇编语言学习过程中，大多数编写的都是PIC.
	- 汇编器指令(Directive)
		- .section
			- mach-o可执行文件的Data部分拥有许多段(Segment), 每个段又有许多节(section). 同一个段的作用往往是类似的，同时在执行的时候一个段会被分配到一个页之中
			- 而.section最常用的格式，就是
				- .section    segname, sectname
			- 在macho中，纯代码被放在了__TEXT段的__text节中，因此，我们在文件的第二行写了
				- .section    __TEXT, __text
				- 代表之后的语句都是__TEXT段的__text节中。
		- .globl
			- 我们在由汇编语言翻译机器码的时候，得到的文件并不仅仅包含操作的指令，还需要包含一些名字和记号。比如说，C语言中，程序执行的起点是main函数。那么，这个函数的名字main就要包含在文件中，使得程序执行的时候知道执行哪个函数。
	- 指令
		- movq
			- 在汇编语言中，这种能直接翻译成机器码的指令被称作助记符(mnemonic).
			- 之前我们也提到过，在GAS语法下，一条指令是助记符+源+目的
				- 也就是说，它后面紧跟的是源操作数，然后是目的操作数。
			- 在x86-64架构下所有的可以被识别的助记符可以参考[64-ia-32-architectures-software-developer-instruction-set-reference-manual](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf)
				- 但值得注意的是，这份官方的参考文档是用的Intel语法，我们只需要把源和目的颠倒过来看就行。
		- $0
			- 在GAS语法下，一个数字前加上`$`表示这个数本身。
			- 如果不加的话，则表示`0`这个地址里存储的数。
			- 此外，我们也可以在前面加`0x`来表示16进制数
		- %rax
			- 我们之前提到，在x86-64架构下，CPU中一共有16个64位通用寄存器
				- 它们的名字依次是rax, rbx, rcx, rdx, rdi, rsi, rbp, rsp, r8, r9, r10, r11, r12, r13, r14, r15.
				- 当我们用这些名字的时候，指的就是这16个64位通用寄存器。
				- 此外，对于前8个通用寄存器，也就是名字不是数字的寄存器，还可以用eax, ebx, ecx, edx, edi, esi, ebp, esp指代其低32位，用ax, bx, cx, dx, di, si, bp, sp指代其低16位。
				- 而对于rax, rbx, rcx, rdx这四个通用寄存器而言，还可以单独引用它低16位中的高8位和低8位，如对ax而言，ah指代其高8位，al指代其低8位。
			- 在GAS语法中，寄存器名字前面一定要跟着`%`.
			- 其他寄存器
				- **通用寄存器**：
				- **程序计数器**：
					- RIP
				- **段寄存器和选择器**：这些寄存器用于在实模式和保护模式下处理内存段。这些寄存器包括：
					- CS (代码段)
					- DS (数据段)
					- ES (附加段)
					- FS (附加段)
					- GS (附加段)
					- SS (堆栈段)
				- **标志寄存器**：
					- RFLAGS
				- **浮点寄存器**：这些寄存器用于处理浮点数操作。它们包括：
					- ST(0) 到 ST(7)
				- **MMX寄存器**：这些寄存器用于处理SIMD（单指令多数据）整数操作。这些寄存器与浮点寄存器共享存储空间。它们包括：
					- MM0 到 MM7
				- **XMM寄存器和YMM寄存器**：
					- 这些寄存器用于处理SIMD浮点和整数操作。在新的处理器上，YMM寄存器是XMM寄存器的扩展，提供了更多的存储空间。这些寄存器包括：
						- XMM0 到 XMM15
						- YMM0 到 YMM15
				- **控制寄存器**：这些寄存器用于控制处理器的操作。这些寄存器包括：
					- CR0 到 CR4
					- CR8
				- **调试寄存器**：这些寄存器用于硬件级别的调试。这些寄存器包括：
					- DR0 到 DR7
			-
	- .equ定义字面量
		- 类似C语言中的\#define 定义的宏
-
	- 局部变量
		- 栈
			- 在操作系统基础中，我们谈到，在一个程序运行的时候，系统会自动给这个程序分配一个栈区。这个栈区和数据结构中所说的栈类似，也支持压栈和弹栈的操作。栈区在逻辑地址空间里是一块连续的空间，栈底是固定的，每次压栈，都会使栈顶向逻辑地址减小的方向移动。
			- rsp寄存器。从它的名字就可以看出来，stack pointer, 它存储的值永远是栈顶的地址，所以它又被叫做栈顶指针。
				- 我们可以用(%rsp)来获取栈顶存储的值，
				- 通过a(%rsp), 其中a是任何一个整数，来获取地址是rsp存储的值加a处的内存单元的值。
					- 比如说，2(%rsp)就是栈顶上方（逻辑地址增大方向）2个字节处的值，
					- -2(%rsp)就是栈顶下方（逻辑地址减小方向）2个字节处的值。
			- 在汇编语言中，压栈和弹栈的助记符分别是push和pop.
				- 这两个操作均有一个操作数。
				- push的操作是将栈顶指针向下移动（也就是将rsp内的值减小），并将移动后rsp对应位置内存区域的值赋为其操作数，而pop则相反。
				- 这里“向下移动”的距离是根据push后面跟着的字母决定的，如pushq就是把rsp内的值减8.
			- 此外，如果是想获得栈顶的值，而不弹栈，可以直接用mov来实现。
				- 如popq   %rax是将栈顶的8个字节内存储的值赋给rax, 并且栈顶指针向上移动8个字节。
				- 而movq   (%rsp), %rax则是只将栈顶的8个字节内存储的值赋给rax, 不涉及栈顶指针的移动。
				- 而如果只想弹栈却不想赋值，那么直接对rsp进行add即可。
					- 如想把栈顶的8个字节的数据弹栈，就直接addq $8, %rsp.
			- 同时，对于push而言，如果我们一下子准备把许多值压入栈内，那么可以先用sub指令减小rsp, 再用mov移动。比如说：
				- ```
				  # method 1
				  pushq	$0x114514
				  pushq	$0x1919
				  pushq	$0x810
				  
				  # method 2
				  subq	$24, %rsp
				  movq	$0x114514, 16(%rsp)
				  movq	$0x1919, 8(%rsp)
				  movq	$0x810, (%rsp)
				  ```
			- 方法一和方法二的最终效果是一样的。但是，我们建议使用方法二，也就是“先sub, 再mov”，因为这样更高效。
		- 使用局部变量
			- 使用局部变量非常简单，就是将局部变量放到栈上，然后使用的时候直接去访问栈上对应的地址空间就行。然后在返回之前，把栈恢复即可。
			- 但是，这里有一个常用的技巧。像上面的例子中写的，我们是通过对rsp中存储的地址加偏移量去访问局部变量，但是，如果我们之后又有了压栈、弹栈的操作，那么，偏移量就会改变。这种不稳定性十分不利于我们编程。
				- 因此，我们又用了另一个寄存器rbp来解决这个问题。
					- rbp, 顾名思义，base pointer, 基地址指针，一般是用来使用偏移量寻址的。
					- 我们使用的技巧是，先将rbp push进栈（之所以保留我会在后面的调用约定里说到），然后利用之前的手法对rsp sub.
					- 然后，利用rbp的偏移量来引用局部变量。
					- 最后在返回前，将rbp赋值给rsp, 此时栈顶指针指向的是最初对rbppush之后的位置，然后将栈顶pop出来给rbp，最后返回。
		- 寻址方式
			- ```
			  $偏移量(%基址，%指标，$倍数）
			  ```
				- 这个记号代表地址为 基址+指标*倍数+偏移量 处的内存单元中存储的值
					- 其中，以\$开头的都是数字（但注意我们真正写的时候不需要加上\$符号）
					- 以%开头的都是寄存器
					- 也就是说，在偏移量、倍数的位置上，不能写寄存器，在基址、指标的位置上，不能写数字。
					- 此外，倍数只能是1, 2, 4, 8中的一个
				- 这四个位置都可以省略，省略的位置将用0代替。
					- 比如说，偏移量(基址)就相当于基址+偏移量, 偏移量(, 指标, 倍数)就相当于 指标*倍数+偏移量.
				- 这样设计寻址方式是由其原因的。
					- 偏移量和基址存在的原因，就是为了解决像我们之前那样通过rsp或者rbp加上偏移量来访问栈上元素的问题。
					- 而指标存在的原因，一是在于，我们不仅可以通过寄存器+数字的方式寻址，也希望通过寄存器+寄存器的方式寻址，也就是(基址, 指标, 1)这样的方式实现寄存器+寄存器寻址
					- 此外，当我们在某些循环操作时，可以每次递减或递增指标，然后实现对一块连续内存的访问。而倍数存在的原因，则是由于存数的时候可能是占1个字节，也可能是2个，4个或8个字节。
			- 那么，有没有一种方式可以让我们获得这个复杂地址本身呢？答案是有的，使用lea.
				- lea是load effective address的简称，其拥有两个操作数。我们可以像这样使用：
					- leaq    -8(%rbp), %rax
		- 全局变量
			- 在汇编语言中，除了__TEXT段以外，还有__DATA段，用于存放数据。
			- 我们知道，当mach-o可执行文件被执行的时候，一个段对应整数个页，因此，__DATA是在逻辑地址空间中是单独的页，
				- 这里存放的数据和字面量不同，拥有自己的地址；
				- 和栈上分配的数据不同，可以被所有函数访问。
			- 在__DATA段中，
				- __data节存放所有非const的已经被初始化过的变量，
				- __bss节存放所有未被初始化的static的变量，
				- __common节存放所有未被初始化过的外部全局变量。
			- 类似于.text，
				- 我们可以用.data来代替.section   __DATA, __data,
				- 用.bss代替.section __DATA, __bss.
			- 小技巧——PC-relative寻址
				- 我们回忆一下之前在操作系统基础中提到的ASLR与PIE. macOS中程序的加载默认是使用ASLR的，也就是说，在程序执行的时候，所有数据的地址都会加上一个随机化的偏移量。
				- \_\_DATA段和__TEXT段之间的距离是没有变的。
					- 因此，无论是执行时还是汇编时，__DATA段的某个数据的地址与当前指令的地址之间的差值是不变的。我们可以利用这一点来实现PIC.
				- 汇编器也对此专门做了优化。
					- 当我们使用寻址方式标签(%rip)时，汇编器不会将其看作rip + 标签，而是会在汇编时就计算出标签距离此指令的下一条指令的地址的距离，然后用距离替换标签。
		- 标签
			- 我们通常使用的标签，定义时是以冒号:结尾的一个标识符，且开头不能是数字。
				- LBB0:, a:, _func:, _main:都是标签的定义
		- 跳转
			- 无条件跳转对应的助记符是jmp. 其操作数是标签。
			- jmp loop_begin就是跳转到loop_begin标记的位置。
			- 这里就有一个问题，这样的跳转，是不是position indenpendent的呢？答案是是的。
				- 但是和之前PC-relative的技巧不同，这里PIC的方法不是程序员做的，而是汇编器做的。
				- 汇编器会直接将jmp翻译成相对跳转的机器码，对程序员来说是透明的。
					- 所以，我们并不需要太过关心这里的PIC.
		- 条件跳转
			- 这是如何做到的呢？
				- 事实上，无论是`cmp`还是别的什么指令，其实大多数都有一个副作用——影响rflags寄存器。rflags寄存器，全称是状态标志寄存器。我们看它不能用十六进制看，要用二进制看。
					- ![image.png](../assets/image_1692541804546_0.png)
				- rflags中某些位是由特定的作用的。我们主要关注其低16位：
					- 每一个以F结尾的都代表一个flag, 比如说CF就是carry flag, 是否进位。
					- 而我们的`cmp`指令，若两数相等，则会把ZF位置`1`，否则置`0`.
					- 而`je`指令，则是当ZF位为`1`时再跳转，否则什么事也不做。
			- 那么一个指令究竟会影响多少位呢，这个在指令集([64-ia-32-architectures-software-developer-instruction-set-reference-manual](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf))中会有详细说明，这里不再赘述。
				- 只强调一点，在做运算时，往往都会涉及标志位的改变。结果是否为零、是否进位、是否溢出等等，都是决定各个标志位的因素。
			- 而依据不同的标志位，有不同的条件跳转指令。
				- 比如说，依据ZF, 有`je`（ZF=`1`时跳转），`jne`（ZF=`0`时跳转）；依据CF, 有`jc`（CF=`1`时跳转），`jnc`（CF=`0`时跳转）。
			- 此外，还有依据多个标志位的跳转指令。但是，我们实际上并不太需要记得跳转指令对应的标志位情况，我们需要记住的是跳转指令对应的逻辑情况，
				- 比如说，`je`代表相等时跳转，`jne`代表不相等时跳转；`jg`代表大于时跳转，`jge`代表大于等于时跳转；`jl`代表小于时跳转，`jle`代表小于等于时跳转。
			- 这里还要强调一下，“大于”、“小于”究竟是谁大谁小。
				- 在我们`cmp	a, b`时，实际上执行的是`b`-`a`, 比较的是`b`和`a`. `b`>`a`，会是`jg`的跳转，而`b`<`a`会是`jl`的跳转。
			- 此外，我们还需要记得大部分非跳转指令对应的标志位的改变。
				- 比如说，`add`指令涉及的标志位就有OF, SF, ZF, AF, CF和PF.
		- 函数
			- 我们知道，在跳转时，有一个特点，那就是跳转了就回不来了。
				- 除非我们在跳转指令之后再加上一个标签，然后在跳转去的部分中找到合适的位置跳转回来。这是比较麻烦的。
				- 所以，跳转指令一般指适用在控制语句中，并不会用于函数的调用。
			- 当我们进行函数调用时，应该使用全新的指令——`call`和`ret`.
				- `call`指令和`jmp`指令一样，接受一个标签作为操作数，直观上看和`jmp`的效果也类似，直接跳转到该标签所在的指令。
				- 但是，`call`指令还干了一件事——把当前的rip寄存器`push`到栈区里。
				- 这实际上和我们利用`jmp`解决跳出去回不来的问题的方法类似，把返回的地址放到栈上。
				- 然后，`call`就没事儿了。
			- 在我们执行完函数的运算之后，想要返回之前调用函数的地方，这该怎么办呢？
				- 就用到了`ret`. `ret`无操作数，默认当前栈顶，也就是rsp指向的位置，存储的是当初`call`时`push`到栈区的地址，然后直接跳转，并且把那个地址弹栈。
			- 因此，在之前提到局部变量的时候，我们在最后恢复了rsp, 让其还是指向最初的位置，目的就是这个。
			- `call`和`ret`都可以加上一个`q`，形成`callq`和`retq`. 这和`call`和`ret`实际上是没有区别的，只是强调那个地址是8个字节的地址。
		- 再探函数
			- 调用约定
				- 汇编语言中的函数，实质只是一个标签所代表的内存地址。
					- 它不像其他高级语言一样，有完整的函数原型体系。
						- 比如说，在C语言中，`int func(int a, char *b)`可以让我们知道，这个函数接受两个参数，第一个是`int`类型的，第二个是`char *`类型的，同时这个函数也返回一个`int`类型的值。
					- 但是，汇编语言中并没有这样的体系。
						- 在我们自己写的程序中，如果调用自己写的函数，那我既可以往rdi里传参数，也可以把参数压入栈里，然后函数再弹栈获得参数；
						- 函数返回既可以返回到rax里，也可以多返回到几个寄存器内实现多返回值。
					- 这一切都是我们自己约定好的。
						- 但是，写程序不只是自己用自己的，也需要用他人的函数，也需要被他人的函数用。那么，我们就应该与他人达成一个约定，如何调用函数，函数会不会改变某些寄存器的值等等。
						- 这叫做调用约定(Calling Convention).
							- 关于调用约定，一定要看的是[System V x86-64 psABI](https://github.com/hjl-tools/x86-psABI). 这个和之前我提到的Intel的x86-64架构官方文档[64-ia-32-architectures-software-developer-instruction-set-reference-manual](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf)一样，都是学习汇编语言一定要多看的文档，建议翻烂。
				- 参数传递
					- 这里传递的参数默认是INTEGER类的，比如说`int`, `long`, `short`, `char`, 以及指针等，也就是除了`double`这种我们在汇编中需要特殊对待的类型以外。
					- 参数传递按从左至右的顺序依次是：rdi, rsi, rdx, rcx, r8, r9. 如果参数多于6个，则将多于6个的部分按从右往左的顺序压入栈内。
						- 这里说明一点，为什么多于6个的时候压栈，是按从右往左的顺序压栈呢？
							- 这样的设计，满足了我们对可变参数的需求。
								- 我们知道，C语言中有`prinf`这个函数。这个函数的参数个数就是可变的，其参数的个数是由从左往右数第一个参数格式化字符串确定的。
								- 在我们程序语言的设计中，往往可变参数的个数都是由从左往右数的某个参数确定的。
								- 那么，我们从右往左压栈，函数内部弹栈获得参数的时候就是按从左往右的顺序，因此就可以在固定的位置获得用于确定可变参数个数的参数。这就是从右往左压栈的好处。
				- 返回值
					- 返回值总是传递到rax上。这也就是我们最初的第一个汇编程序，返回的时候把`$0`赋给rax的原因。
					-
			-
			-