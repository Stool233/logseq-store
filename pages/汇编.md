- mac下的汇编
	- 来源：
		- https://github.com/Evian-Zhang/Assembly-on-macOS
	- Mach-O文件结构
		- 在macOS上的可执行文件，都是Mach-O格式的文件
		- 关于Mach-O文件，详细可参考Apple官方文档[Mach-O Programming Topics](https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/MachOTopics/0-Introduction/introduction.html). 这里我们只是简单介绍一下。
			- ![image.png](../assets/image_1692539618318_0.png){:height 489, :width 431}
		- Mach-O文件由头(Header)、装载指令(Load commands)和数据(Data)组成。
			- 我们可以通过[MachOView](https://github.com/fangshufeng/MachOView)软件进行查看。
		- 其中，最重要的组成部分就是Data.
			- 我们可以从图中看到，Data可以分为多个段(Segment), 每个段又可以分为多个节(Section).
			- 从逻辑角度来看，每个段内的节存储的数据都有类似的目的。
			- 如`__TEXT`段内存储的有汇编源代码、字符串等，`__DATA`段内存储非常量初始化变量等。
			- 从内存管理角度来看，每个段的大小被要求是页大小的倍数，也就是4096B的倍数。
			- 当程序加载时，就可以正好将一个段加载到一个页内。
	- 栈
		- 当程序运行时，系统会自动给这个进程分配一个栈。这里的栈的数据结构就是数据结构中所说的栈，也就是先进后出的线性表。在x86-64架构下，栈是向下生长的。也就是说，每向栈中`PUSH`一个数据，栈顶的指针就会向逻辑地址减小的方向移动。
	- ASLR
		- 从Mac OS X 10.5开始，Apple引入了地址空间配置随机加载(ASLR)机制。在每次程序执行的过程中，程序在内存中的开始地址，堆、栈、库的地址都会随机化，这样可以更好地保护不受攻击者攻击。
	- PIE
		- 在ASLR中我们可以看到，大部分变量在每次运行时的逻辑地址都不一样。那么，我们在汇编层面访问这些变量时，就不能直接访问一个固定的逻辑地址。
		- 因此，我们在汇编语言中有许多技巧可以生成位置无关代码(Position Independent Code, PIC).
			- 这些代码中没有一处会直接访问固定的逻辑地址。
			- 由位置无关代码编译生成的可执行文件称为位置无关可执行文件(Position Independent Executable, PIE).
			- 在我们在macOS上的汇编语言学习过程中，大多数编写的都是PIC.
	- 汇编器指令(Directive)
		- .section
			- mach-o可执行文件的Data部分拥有许多段(Segment), 每个段又有许多节(section). 同一个段的作用往往是类似的，同时在执行的时候一个段会被分配到一个页之中
			- 而.section最常用的格式，就是
				- .section    segname, sectname
			- 在macho中，纯代码被放在了__TEXT段的__text节中，因此，我们在文件的第二行写了
				- .section    __TEXT, __text
				- 代表之后的语句都是__TEXT段的__text节中。
		- .globl
			- 我们在由汇编语言翻译机器码的时候，得到的文件并不仅仅包含操作的指令，还需要包含一些名字和记号。比如说，C语言中，程序执行的起点是main函数。那么，这个函数的名字main就要包含在文件中，使得程序执行的时候知道执行哪个函数。
	- 指令
		- movq
			- 在汇编语言中，这种能直接翻译成机器码的指令被称作助记符(mnemonic).
			- 之前我们也提到过，在GAS语法下，一条指令是助记符+源+目的
				- 也就是说，它后面紧跟的是源操作数，然后是目的操作数。
			- 在x86-64架构下所有的可以被识别的助记符可以参考[64-ia-32-architectures-software-developer-instruction-set-reference-manual](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf)
				- 但值得注意的是，这份官方的参考文档是用的Intel语法，我们只需要把源和目的颠倒过来看就行。
		- $0
			- 在GAS语法下，一个数字前加上`$`表示这个数本身。
			- 如果不加的话，则表示`0`这个地址里存储的数。
			- 此外，我们也可以在前面加`0x`来表示16进制数
		- %rax
			- 我们之前提到，在x86-64架构下，CPU中一共有16个64位通用寄存器
				- 它们的名字依次是rax, rbx, rcx, rdx, rdi, rsi, rbp, rsp, r8, r9, r10, r11, r12, r13, r14, r15.
				- 当我们用这些名字的时候，指的就是这16个64位通用寄存器。
				- 此外，对于前8个通用寄存器，也就是名字不是数字的寄存器，还可以用eax, ebx, ecx, edx, edi, esi, ebp, esp指代其低32位，用ax, bx, cx, dx, di, si, bp, sp指代其低16位。
				- 而对于rax, rbx, rcx, rdx这四个通用寄存器而言，还可以单独引用它低16位中的高8位和低8位，如对ax而言，ah指代其高8位，al指代其低8位。
			- 在GAS语法中，寄存器名字前面一定要跟着`%`.
			- 其他寄存器
				- **通用寄存器**：
				- **程序计数器**：
					- RIP
				- **段寄存器和选择器**：这些寄存器用于在实模式和保护模式下处理内存段。这些寄存器包括：
					- CS (代码段)
					- DS (数据段)
					- ES (附加段)
					- FS (附加段)
					- GS (附加段)
					- SS (堆栈段)
				- **标志寄存器**：
					- RFLAGS
				- **浮点寄存器**：这些寄存器用于处理浮点数操作。它们包括：
					- ST(0) 到 ST(7)
				- **MMX寄存器**：这些寄存器用于处理SIMD（单指令多数据）整数操作。这些寄存器与浮点寄存器共享存储空间。它们包括：
					- MM0 到 MM7
				- **XMM寄存器和YMM寄存器**：
					- 这些寄存器用于处理SIMD浮点和整数操作。在新的处理器上，YMM寄存器是XMM寄存器的扩展，提供了更多的存储空间。这些寄存器包括：
						- XMM0 到 XMM15
						- YMM0 到 YMM15
				- **控制寄存器**：这些寄存器用于控制处理器的操作。这些寄存器包括：
					- CR0 到 CR4
					- CR8
				- **调试寄存器**：这些寄存器用于硬件级别的调试。这些寄存器包括：
					- DR0 到 DR7
	- .equ定义字面量
		- 类似C语言中的\#define 定义的宏
-
	- 局部变量
	  collapsed:: true
		- 栈
			- 在操作系统基础中，我们谈到，在一个程序运行的时候，系统会自动给这个程序分配一个栈区。这个栈区和数据结构中所说的栈类似，也支持压栈和弹栈的操作。栈区在逻辑地址空间里是一块连续的空间，栈底是固定的，每次压栈，都会使栈顶向逻辑地址减小的方向移动。
			- rsp寄存器。从它的名字就可以看出来，stack pointer, 它存储的值永远是栈顶的地址，所以它又被叫做栈顶指针。
				- 我们可以用(%rsp)来获取栈顶存储的值，
				- 通过a(%rsp), 其中a是任何一个整数，来获取地址是rsp存储的值加a处的内存单元的值。
					- 比如说，2(%rsp)就是栈顶上方（逻辑地址增大方向）2个字节处的值，
					- -2(%rsp)就是栈顶下方（逻辑地址减小方向）2个字节处的值。
			- 在汇编语言中，压栈和弹栈的助记符分别是push和pop.
				- 这两个操作均有一个操作数。
				- push的操作是将栈顶指针向下移动（也就是将rsp内的值减小），并将移动后rsp对应位置内存区域的值赋为其操作数，而pop则相反。
				- 这里“向下移动”的距离是根据push后面跟着的字母决定的，如pushq就是把rsp内的值减8.
			- 此外，如果是想获得栈顶的值，而不弹栈，可以直接用mov来实现。
				- 如popq   %rax是将栈顶的8个字节内存储的值赋给rax, 并且栈顶指针向上移动8个字节。
				- 而movq   (%rsp), %rax则是只将栈顶的8个字节内存储的值赋给rax, 不涉及栈顶指针的移动。
				- 而如果只想弹栈却不想赋值，那么直接对rsp进行add即可。
					- 如想把栈顶的8个字节的数据弹栈，就直接addq $8, %rsp.
			- 同时，对于push而言，如果我们一下子准备把许多值压入栈内，那么可以先用sub指令减小rsp, 再用mov移动。比如说：
				- ```
				  # method 1
				  pushq	$0x114514
				  pushq	$0x1919
				  pushq	$0x810
				  
				  # method 2
				  subq	$24, %rsp
				  movq	$0x114514, 16(%rsp)
				  movq	$0x1919, 8(%rsp)
				  movq	$0x810, (%rsp)
				  ```
			- 方法一和方法二的最终效果是一样的。但是，我们建议使用方法二，也就是“先sub, 再mov”，因为这样更高效。
		- 使用局部变量
			- 使用局部变量非常简单，就是将局部变量放到栈上，然后使用的时候直接去访问栈上对应的地址空间就行。然后在返回之前，把栈恢复即可。
			- 但是，这里有一个常用的技巧。像上面的例子中写的，我们是通过对rsp中存储的地址加偏移量去访问局部变量，但是，如果我们之后又有了压栈、弹栈的操作，那么，偏移量就会改变。这种不稳定性十分不利于我们编程。
				- 因此，我们又用了另一个寄存器rbp来解决这个问题。
					- rbp, 顾名思义，base pointer, 基地址指针，一般是用来使用偏移量寻址的。
					- 我们使用的技巧是，先将rbp push进栈（之所以保留我会在后面的调用约定里说到），然后利用之前的手法对rsp sub.
					- 然后，利用rbp的偏移量来引用局部变量。
					- 最后在返回前，将rbp赋值给rsp, 此时栈顶指针指向的是最初对rbppush之后的位置，然后将栈顶pop出来给rbp，最后返回。
		- 寻址方式
			- ```
			  $偏移量(%基址，%指标，$倍数）
			  ```
				- 这个记号代表地址为 基址+指标*倍数+偏移量 处的内存单元中存储的值
					- 其中，以\$开头的都是数字（但注意我们真正写的时候不需要加上\$符号）
					- 以%开头的都是寄存器
					- 也就是说，在偏移量、倍数的位置上，不能写寄存器，在基址、指标的位置上，不能写数字。
					- 此外，倍数只能是1, 2, 4, 8中的一个
				- 这四个位置都可以省略，省略的位置将用0代替。
					- 比如说，偏移量(基址)就相当于基址+偏移量, 偏移量(, 指标, 倍数)就相当于 指标*倍数+偏移量.
				- 这样设计寻址方式是由其原因的。
					- 偏移量和基址存在的原因，就是为了解决像我们之前那样通过rsp或者rbp加上偏移量来访问栈上元素的问题。
					- 而指标存在的原因，一是在于，我们不仅可以通过寄存器+数字的方式寻址，也希望通过寄存器+寄存器的方式寻址，也就是(基址, 指标, 1)这样的方式实现寄存器+寄存器寻址
					- 此外，当我们在某些循环操作时，可以每次递减或递增指标，然后实现对一块连续内存的访问。而倍数存在的原因，则是由于存数的时候可能是占1个字节，也可能是2个，4个或8个字节。
			- 那么，有没有一种方式可以让我们获得这个复杂地址本身呢？答案是有的，使用lea.
				- lea是load effective address的简称，其拥有两个操作数。我们可以像这样使用：
					- leaq    -8(%rbp), %rax
		- 全局变量
			- 在汇编语言中，除了__TEXT段以外，还有__DATA段，用于存放数据。
			- 我们知道，当mach-o可执行文件被执行的时候，一个段对应整数个页，因此，__DATA是在逻辑地址空间中是单独的页，
				- 这里存放的数据和字面量不同，拥有自己的地址；
				- 和栈上分配的数据不同，可以被所有函数访问。
			- 在__DATA段中，
				- __data节存放所有非const的已经被初始化过的变量，
				- __bss节存放所有未被初始化的static的变量，
				- __common节存放所有未被初始化过的外部全局变量。
			- 类似于.text，
				- 我们可以用.data来代替.section   __DATA, __data,
				- 用.bss代替.section __DATA, __bss.
			- 小技巧——PC-relative寻址
				- 我们回忆一下之前在操作系统基础中提到的ASLR与PIE. macOS中程序的加载默认是使用ASLR的，也就是说，在程序执行的时候，所有数据的地址都会加上一个随机化的偏移量。
				- \_\_DATA段和__TEXT段之间的距离是没有变的。
					- 因此，无论是执行时还是汇编时，__DATA段的某个数据的地址与当前指令的地址之间的差值是不变的。我们可以利用这一点来实现PIC.
				- 汇编器也对此专门做了优化。
					- 当我们使用寻址方式标签(%rip)时，汇编器不会将其看作rip + 标签，而是会在汇编时就计算出标签距离此指令的下一条指令的地址的距离，然后用距离替换标签。
		- 标签
			- 我们通常使用的标签，定义时是以冒号:结尾的一个标识符，且开头不能是数字。
				- LBB0:, a:, _func:, _main:都是标签的定义
		- 跳转
			- 无条件跳转对应的助记符是jmp. 其操作数是标签。
			- jmp loop_begin就是跳转到loop_begin标记的位置。
			- 这里就有一个问题，这样的跳转，是不是position indenpendent的呢？答案是是的。
				- 但是和之前PC-relative的技巧不同，这里PIC的方法不是程序员做的，而是汇编器做的。
				- 汇编器会直接将jmp翻译成相对跳转的机器码，对程序员来说是透明的。
					- 所以，我们并不需要太过关心这里的PIC.
		- 条件跳转
			- 这是如何做到的呢？
				- 事实上，无论是`cmp`还是别的什么指令，其实大多数都有一个副作用——影响rflags寄存器。rflags寄存器，全称是状态标志寄存器。我们看它不能用十六进制看，要用二进制看。
					- ![image.png](../assets/image_1692541804546_0.png)
				- rflags中某些位是由特定的作用的。我们主要关注其低16位：
					- 每一个以F结尾的都代表一个flag, 比如说CF就是carry flag, 是否进位。
					- 而我们的`cmp`指令，若两数相等，则会把ZF位置`1`，否则置`0`.
					- 而`je`指令，则是当ZF位为`1`时再跳转，否则什么事也不做。
			- 那么一个指令究竟会影响多少位呢，这个在指令集([64-ia-32-architectures-software-developer-instruction-set-reference-manual](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf))中会有详细说明，这里不再赘述。
				- 只强调一点，在做运算时，往往都会涉及标志位的改变。结果是否为零、是否进位、是否溢出等等，都是决定各个标志位的因素。
			- 而依据不同的标志位，有不同的条件跳转指令。
				- 比如说，依据ZF, 有`je`（ZF=`1`时跳转），`jne`（ZF=`0`时跳转）；依据CF, 有`jc`（CF=`1`时跳转），`jnc`（CF=`0`时跳转）。
			- 此外，还有依据多个标志位的跳转指令。但是，我们实际上并不太需要记得跳转指令对应的标志位情况，我们需要记住的是跳转指令对应的逻辑情况，
				- 比如说，`je`代表相等时跳转，`jne`代表不相等时跳转；`jg`代表大于时跳转，`jge`代表大于等于时跳转；`jl`代表小于时跳转，`jle`代表小于等于时跳转。
			- 这里还要强调一下，“大于”、“小于”究竟是谁大谁小。
				- 在我们`cmp	a, b`时，实际上执行的是`b`-`a`, 比较的是`b`和`a`. `b`>`a`，会是`jg`的跳转，而`b`<`a`会是`jl`的跳转。
			- 此外，我们还需要记得大部分非跳转指令对应的标志位的改变。
				- 比如说，`add`指令涉及的标志位就有OF, SF, ZF, AF, CF和PF.
		- 函数
			- 我们知道，在跳转时，有一个特点，那就是跳转了就回不来了。
				- 除非我们在跳转指令之后再加上一个标签，然后在跳转去的部分中找到合适的位置跳转回来。这是比较麻烦的。
				- 所以，跳转指令一般指适用在控制语句中，并不会用于函数的调用。
			- 当我们进行函数调用时，应该使用全新的指令——`call`和`ret`.
				- `call`指令和`jmp`指令一样，接受一个标签作为操作数，直观上看和`jmp`的效果也类似，直接跳转到该标签所在的指令。
				- 但是，`call`指令还干了一件事——把当前的rip寄存器`push`到栈区里。
				- 这实际上和我们利用`jmp`解决跳出去回不来的问题的方法类似，把返回的地址放到栈上。
				- 然后，`call`就没事儿了。
			- 在我们执行完函数的运算之后，想要返回之前调用函数的地方，这该怎么办呢？
				- 就用到了`ret`. `ret`无操作数，默认当前栈顶，也就是rsp指向的位置，存储的是当初`call`时`push`到栈区的地址，然后直接跳转，并且把那个地址弹栈。
			- 因此，在之前提到局部变量的时候，我们在最后恢复了rsp, 让其还是指向最初的位置，目的就是这个。
			- `call`和`ret`都可以加上一个`q`，形成`callq`和`retq`. 这和`call`和`ret`实际上是没有区别的，只是强调那个地址是8个字节的地址。
	- 再探函数
		- 调用约定
		  collapsed:: true
			- 汇编语言中的函数，实质只是一个标签所代表的内存地址。
				- 它不像其他高级语言一样，有完整的函数原型体系。
					- 比如说，在C语言中，`int func(int a, char *b)`可以让我们知道，这个函数接受两个参数，第一个是`int`类型的，第二个是`char *`类型的，同时这个函数也返回一个`int`类型的值。
				- 但是，汇编语言中并没有这样的体系。
					- 在我们自己写的程序中，如果调用自己写的函数，那我既可以往rdi里传参数，也可以把参数压入栈里，然后函数再弹栈获得参数；
					- 函数返回既可以返回到rax里，也可以多返回到几个寄存器内实现多返回值。
				- 这一切都是我们自己约定好的。
					- 但是，写程序不只是自己用自己的，也需要用他人的函数，也需要被他人的函数用。那么，我们就应该与他人达成一个约定，如何调用函数，函数会不会改变某些寄存器的值等等。
					- 这叫做调用约定(Calling Convention).
						- 关于调用约定，一定要看的是[System V x86-64 psABI](https://github.com/hjl-tools/x86-psABI). 这个和之前我提到的Intel的x86-64架构官方文档[64-ia-32-architectures-software-developer-instruction-set-reference-manual](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf)一样，都是学习汇编语言一定要多看的文档，建议翻烂。
			- 参数传递
				- 这里传递的参数默认是INTEGER类的，比如说`int`, `long`, `short`, `char`, 以及指针等，也就是除了`double`这种我们在汇编中需要特殊对待的类型以外。
				- 参数传递按从左至右的顺序依次是：rdi, rsi, rdx, rcx, r8, r9. 如果参数多于6个，则将多于6个的部分按从右往左的顺序压入栈内。
					- 这里说明一点，为什么多于6个的时候压栈，是按从右往左的顺序压栈呢？
						- 这样的设计，满足了我们对可变参数的需求。
							- 我们知道，C语言中有`prinf`这个函数。这个函数的参数个数就是可变的，其参数的个数是由从左往右数第一个参数格式化字符串确定的。
							- 在我们程序语言的设计中，往往可变参数的个数都是由从左往右数的某个参数确定的。
							- 那么，我们从右往左压栈，函数内部弹栈获得参数的时候就是按从左往右的顺序，因此就可以在固定的位置获得用于确定可变参数个数的参数。这就是从右往左压栈的好处。
			- 返回值
				- 返回值总是传递到rax上。
				- 这也就是我们最初的第一个汇编程序，返回的时候把`$0`赋给rax的原因。
			- 保留寄存器
				- 在我们调用函数的时候，还要遵循一个约定，那就是哪些寄存器是保留寄存器。
					- 比如说，我在函数`_func`里面，修改了寄存器rbx的值，那么我在主函数中，`callq	_func`之后，并没有任何表征告诉我们rbx的值改变了，那么我们在后续的编程中就有可能使用了错误的rbx值。
					- 因此，在函数执行的时候，哪些寄存器应当保留，也属于调用约定。
				- 在这里，称调用的函数为called函数，调用called函数的函数称为calling函数。比如说：
					- ```
					  _main:
					  	callq	_func
					  	retq
					  	
					  _func:
					  	# do something
					     
					  ```
					- 中，`_main`就是calling函数，`_func`就是called函数。
					- 寄存器rbp, rbx, r12, r13, r14, r15是属于calling函数，其余的寄存器都属于called函数。called函数在使用上述寄存器的时候，应当对寄存器的初始值予以保留。
				- 保留的最有效的方法就是将其`push`上栈，在返回之前再`pop`回来。
					- 这也就是我们当初在局部变量的时候，在使用rbp标记最初栈顶之前，首先要`pushq	%rbp`, 在函数返回之前，又要`popq	%rbp`.
					- 同时我们也应当注意到，这也意味着我们在调用别的函数的时候，只能默认上述那几个寄存器在调用之后不会被改变，而别的寄存器是又可能被改变的。
		- 函数调用
		  collapsed:: true
			- 在讲完了调用约定之后，我们接下来再讨论一下函数调用的问题。
			- 调用本文件中的函数
				- 就是最基础的情况，自己调用本文件中自己写的函数，不需要任何别的东西，直接`call`就好了。
			- 调用别的汇编文件中的函数
				- 这里既有可能是自己写的多文件，也有可能是他人写的。
				- 如果要调用别的文件中的函数，那么这个函数在它被定义的那个文件中一定要是被`.globl`声明过的。
				- 假设有两个汇编文件`my.s`和`other.s`, 我们只需要在终端下依次键入
					- ```
					  as my.s -o my.o
					  as other.s -o other.o
					  ld my.o other.o -o my -lSystem
					  ```
					- 这里要求`my.s`和`other.s`不能同时有`_main`.
			- 调用C语言中的函数
				- 假设我有一个C语言中的函数`int func(int a, int b, int c)`.
					- 那么我如果想在别的汇编代码中调用这个函数，只需要将这个函数的名字前加一个`_`. 也就是`callq	_func`即可。
					- 参数传递和返回值都是按之前说的调用约定来做。
				- 假设C语言的代码叫做`test.c`, 汇编语言的代码叫做`main.o`, 那么我们只需要在终端下依次键入
					- ```
					  clang test.c -c -o test.o
					  as main.s -o main.o
					  ld test.o main.o -o main -lSystem
					  ```
			- 调用库函数
				- 操作系统提供了大量的库。在macOS中，大量的库函数都包含在文件`/usr/lib/libSystem.dylib`中。包括：
					- `libc`
					  C标准库
					- `libinfo`
					  NetInfo库
					- `libkvm`
					  内核虚存库
					- `libm`
					  数学库
					- `libpthread`
					  POSIX线程库
				- 这些库的C头文件我们可以在`/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk 1/usr/include/`目录下找到。
				- 我们在链接时的参数`-lSystem`就代表链接`libSystem.dylib`.
					- 因此，我们不需要再额外做任何工作，就能按照上述的调用C语言的方式调用系统库的函数了。
					- 因此，我们心心念念的`printf`终于可以用了！只不过要在前面加上`_`.
				- 不过，还有一点额外要注意的。在调用库函数的时候，栈需要16字节对齐。
					- 在之前提到的调用约定中，其实还有一点，就是栈对齐。由于我们写函数的时候总是会在第一步就`pushq	%rbp`
					- 同时再在这个函数中用`call`调用别的函数的时候，实际上又把返回地址压栈。
					- 因此，called函数的起始栈地址，比calling函数的起始栈地址高了16个字节。
					- 硬件开发者就这个特点，进行了优化。导致栈进行16字节对齐的时候，效率会特别高。因此，这也就作为了一项调用约定。
				- 栈16字节对齐究竟是什么意思呢？
					- 首先，我们的`_main`函数默认其进入的时候，rsp寄存器内的地址值是16字节的倍数。
					- 接下来，我们如果要`call`任何库函数，要保证在`call`之前，`8(%rsp)`, 也就是rsp寄存器内的地址值加8，应当是16的倍数。
					- 因此，我们来算一下：
						- 在`_main`的最开始，rsp寄存器内的地址值是16的倍数；
						- 接下来一般人都会`pushq	%rbp`
						- 这时，rsp寄存器内的地址值是16的倍数加8.
						- 因此，我们在接下来利用栈分配局部变量的时候，一定要让增加的栈空间是16的倍数。
						- 因此，即使只有3个`long`型的局部变量，也要将rsp减32, 而不是减24.
			- 被调用
				- 被调用的最典型的例子，就是命令行参数`argc`与`argv`了。
					- `argc`是在命令行中该程序被调用时参数的个数，`argv`是一个`char **`类型，是各个参数的字符串数组。
						- 比如说
							- ```
							  ./test	helloworld 1
							  ```
						- 那么，`argc`就是3，`argv[0]`是`"./test"`, `argv[1]`是`"helloworld"`, `argv[2]`是`"1"`.
						- 操作系统会自动将`argc`和`argv`作为`_main`函数的参数传给程序。因此，我们在`_main`的开始，就可以用rdi获得`argc`, `rsi`获得argv.
			- 被C语言调用
				- 和调用C语言时在函数名前加`_`相反, 被C语言调用时，C代码中要把汇编语言函数前的`_`去掉。
					- 比如说汇编语言中有一个函数`_func`, 那么在C语言中调用的函数就应当是`func()`. 此外，需要在C语言代码的开头写上
						- ``` extern void func(); ```
						- 其中函数的返回值和参数都可以依据汇编语言来定，也可以写`extern int func(int a);`这种。
	- 系统调用
		- 所谓系统调用(System call), 就是指操作系统提供的接口。
			- 我们知道，现代的操作系统分为内核态和用户态。
				- 我们平时的汇编语言的执行过程中，都是在用户态执行的。
				- 但是，有一些核心的功能，如文件的读写、进程的创建等，都是在内核态实现的。
					- 这时候，就需要我们去调用操作系统提供给我们的接口来实现。
		- 有哪些系统调用
			- 我们前往`/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys`这个目录，找到一个叫`syscall.h`的文件。这个文件的格式如下：
				- ```
				  #define	SYS_syscall        0
				  #define	SYS_exit           1
				  #define	SYS_fork           2
				  #define	SYS_read           3
				  #define	SYS_write          4
				  #define	SYS_open           5
				  #define	SYS_close          6
				  #define	SYS_wait4          7
				  ```
				- 第二列是系统调用的名字，第三列是系统调用号。
			- 系统调用实质上是操作系统提供给我们的一个C函数接口，那么，我们去哪里找系统调用的函数原型呢？
				- 这个相对比较麻烦。首先，我们前往Apple官方的开源网站[opensource.apple](https://opensource.apple.com/), 然后会发现每个版本的macOS都有一部分开源的文件。
				- 进入任意一个版本的开源目录下，可以找到一个以`xnu`开头的目录。这就是每个版本的内核代码，直接下载即可。
					- 如果不在意版本号，那么可以直接前往其在GitHub上的镜像[apple/darwin-xnu](https://github.com/apple/darwin-xnu)下载即可。
				- 在下载好的`xnu`目录下，前往子目录`bsd/kern/`中，找到一个文件`syscalls.master`. 这就是所有系统调用的函数原型。我们可以利用命令行工具`cat`进行查看。其文件格式如下：
					- ```
					  0	AUE_NULL	ALL	{ int nosys(void); }   { indirect syscall }
					  1	AUE_EXIT	ALL	{ void exit(int rval) NO_SYSCALL_STUB; } 
					  2	AUE_FORK	ALL	{ int fork(void) NO_SYSCALL_STUB; } 
					  3	AUE_NULL	ALL	{ user_ssize_t read(int fd, user_addr_t cbuf, user_size_t nbyte); } 
					  4	AUE_NULL	ALL	{ user_ssize_t write(int fd, user_addr_t cbuf, user_size_t nbyte); } 
					  5	AUE_OPEN_RWTC	ALL	{ int open(user_addr_t path, int flags, int mode) NO_SYSCALL_STUB; } 
					  6	AUE_CLOSE	ALL	{ int close(int fd); } 
					  7	AUE_WAIT4	ALL	{ int wait4(int pid, user_addr_t status, int options, user_addr_t rusage) NO_SYSCALL_STUB; } 
					  ```
					- 其第一列是系统调用号，第四列则是函数原型。
		- 如何使用系统调用
			- 使用系统调用和使用系统库函数类似，但是，系统库函数我们可以利用函数名进行调用，如`_exit`, `_printf`等。但是，我们使用系统调用，则只能利用系统调用号进行调用。
				- 这里还有一点需要注意的，就是之前在操作系统基础中提到过，macOS的内核XNU是分为BSD层和Mach层。
				- 我们常用的系统调用都属于BSD的系统调用。
					- 而BSD层在逻辑地址上是位于Mach层之上的，BSD层要从`0x2000000`开始。
					- 因此，我们实际使用的调用号应该是`syscall.h`给出的调用号加上`0x2000000`之后的结果，如`SYS_exit`的调用号就应当是`0x2000001`.
			- 在汇编语言中，系统调用号应赋给rax寄存器，然后接下来系统调用的参数按照之前讲的调用约定，依次传给rdi, rsi等寄存器中。最后，使用`syscall`即可。
				- ```
				  	movq	$0x2000001, %rax
				  	movq	$0, %rdi
				  	syscall
				  ```
				- 我们首先将系统调用号`0x2000001`赋给rax寄存器，
				- 然后根据其函数原型`void exit(int rval)`, 其接受一个参数作为整个进程的返回值，因此，我们将`0`赋给rdi寄存器，
				- 然后使用`syscall`进行系统调用。
		- 进程的返回
			- `exit`和`return`有什么区别呢？
				- 事实上，`exit`是真正的进程退出，执行完`exit`之后，进程就彻底没了。
				- 但是，`return`并不是这样。
					- 事实上，操作系统在加载一个程序进内存时，动态链接了一个目标文件`crt1.o`, 这个文件位于`/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk 1/usr/lib/`目录下。
					- 这个文件做了什么呢？它可以理解为
						- ```
						  int rVal = main(argc, argv);
						  exit(rVal);
						  ```
						- 这段C程序。它找到我们想要执行的文件的`main`函数（在汇编中是`_main`函数），然后将`argc`和`argv`当作`main`函数的参数传递给它。
						- 在`main`函数执行完后，会有一个返回值，这也是我们写`return 0;`的目的，这时`rVal`的值就是`main`函数的返回值`0`. 最后，调用`exit`进行退出。
					- 因此，我们虽然可以在`main`函数中直接用`exit(0);`进行退出，就相当于不执行最后一行代码。但是，更优雅的方法显然是`return 0;`.
	- 从编译到执行
		- 编译
			- 编译并不是对汇编代码来说的，而是对更高级的语言，如C、C++来说的。
			- 如果一个语言最终的编译结果是可执行文件，那么它一定会先被编译为汇编语言，然后再被汇编、链接为可执行文件。
			- 对于C和C++来说，大部分的编译器都支持输出汇编结果。
				- 比如说对于`test.c`, 我们想查看其编译后的汇编代码，只需要在命令行中键入
					- ```
					  clang test.c -S -o test.s
					  ```
					- 然后就会生成一个包含其汇编代码的`test.s`文件。
			- 研究编译器生成的汇编代码很有意义。
				- 因为现代的编译器，其都针对不同的平台、架构有许多优化，这对于我们写汇编代码是很有意义的。比如说，对``return 0;``的编译结果，是
					- ```
					  xorl	%eax, %eax
					  retq
					  ```
					- 事实上，通过异或自身来清零这一操作，在任何架构上都是最高效的。
		- 汇编
			- 所谓汇编，就是输入我们的汇编代码，输出目标文件。
			- 什么是目标文件呢？
				- 假设我们有一个汇编文件`test.s`, 然后我们利用
					- ```
					  as test.s -o test.o
					  ```
				- 生成一个`test.o`文件。然后，我们在终端下利用`file`指令查看其文件类型：
					- ```
					  $ file test.o
					  test.o: Mach-O 64-bit object x86_64
					  ```
					- 可以看到， 这个文件是object, 也就是目标文件。
			- 那么，目标文件是做什么用的呢？
				- 要了解这个，首先我们需要知道「汇编」这一步骤究竟做了什么。
					- 我们知道，汇编语言可以看作机器码的human-readable版本。
						- 因此，从最直观来看，汇编只需要把汇编代码翻译为机器码就ok了，也就是汇编代码直接变成可执行文件。
						- 这个粗略来看是对的，对于大多数代码来说，确实直接翻译为机器码就好了。
						- 但是，如果真的是这样，随着人们写的代码越来越多，汇编器的有一项工作的负担就越来越重——翻译符号。
							- 我们之前在汇编语言中大量运用了标签，一个标签就对应一个地址。
							- 此外，我们也可以引用别的文件、动态链接库的标签。
							- 因此，对于一个标签，其可能的情况有好多好多种。
						- 所以，人们就把这部分功能从汇编器中解放出来，同时，汇编器就变成了对于一个汇编文件，输出其目标文件。
						-