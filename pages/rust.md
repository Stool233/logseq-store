- 所有权
	- 所有权规则
		- Rust中的每一个值都有一个对应的变量作为它的所有者。
		- 在同一时间内，值有且仅有一个所有者。
		- 当所有者离开自己的作用域时，它持有的值就会被释放掉。
	- 内存与分配
		- 内存会自动地在拥有它的变量离开作用域后进行释放。
			- ![image.png](../assets/image_1679843723209_0.png){:height 129, :width 562}
			-
			- Rust在变量离开作用域时，会调用一个叫作drop的特殊函数。
				- String类型的作者可以在这个函数中编写释放内存的代码。
			- 记住，Rust会在作用域结束的地方（即}处）自动调用drop函数。
			- 注意
				- 在C++中，这种在对象生命周期结束时释放资源的模式有时也被称作资源获取即初始化（Resource Acquisition Is Initialization， RAII）。
		- 变量和数据交互的方式：移动
		- 变量和数据交互的方式：克隆
	- 所有权与函数
		- 将值传递给函数在语义上类似于对变量进行赋值。将变量传递给函数将会触发移动或复制，就像是赋值语句一样。
	- 返回值与作用域
		- 函数在返回值的过程中也会发生所有权的转移。
		- 变量所有权的转移总是遵循相同的模式：
			- 将一个值赋值给另一个变量时就会转移所有权。
			- 当一个持有堆数据的变量离开作用域时，它的数据就会被drop清理回收，除非这些数据的所有权移动到了另一个变量上。
- 引用与借用
	- 这些&代表的就是引用语义，它们允许你在不获取所有权的前提下使用值。图4-5所展示的是该过程的一个图解。
		- ![image.png](../assets/image_1679892751898_0.png){:height 333, :width 557}
		- 与使用&进行引用相反的操作被称为解引用（dereferencing），它使用*作为运算符。
	- 这里的&s1语法允许我们在不转移所有权的前提下，创建一个指向s1值的引用。由于引用不持有值的所有权，所以当引用离开当前作用域时，它指向的值也不会被丢弃。
	- 同理，函数签名中的&用来表明参数s的类型是一个引用。
		- ```rust
		  fn calculate_length(s: &String) -> usize { // s 是一个指向 String 的引用
		      s.len()
		  } // 到这里，s离开作用域。但是由于它并不持有自己所指向值的所有权，
		  //所以没有什么特殊的事情会发生
		  ```
		- 此处，变量s的有效作用域与其他任何函数参数一样，唯一不同的是，它不会在离开自己的作用域时销毁其指向的数据，因为它并不拥有该数据的所有权。
		- 当一个函数使用引用而不是值本身作为参数时，我们便不需要为了归还所有权而特意去返回值，毕竟在这种情况下，我们根本没有取得所有权。
	- 这种通过引用传递参数给函数的方法也被称为借用（borrowing）。
	- 引用的规则
		- 在任何一段给定的时间里，你要么只能拥有一个可变引用，要么只能拥有任意数量的不可变引用。
		- 引用总是有效的。
- 生命周期
	- 悬垂指针和生命周期
		- 生命周期的主要作用是避免悬垂引用，它会导致程序引用了本不该引用的数据
	- 借用检查
		- 为了保证 Rust 的所有权和借用的正确性，Rust 使用了一个借用检查器(Borrow checker)，来检查我们程序的借用正确性
-
- 在 Rust 中，`derive` 和 `repr` 是两个非常有用的属性（attributes），它们为类型提供了元数据，允许编译器执行一些自定义的行为。
	- ### `#[derive(...)]`
		- `derive` 属性用来自动为类型实现一些特定的 trait。
			- Trait 是 Rust 中的一种功能，它定义了方法的签名，这些方法可以实现为某种类型的行为。当你使用 `derive` 属性时，编译器会为你的类型生成这些方法的标准实现，而不需要你手动编写代码。
		- 下面是一些可以通过 `derive` 自动实现的常见 trait：
			- `Debug`: 允许实例通过 `println!("{:?}", instance);` 方式进行格式化打印，主要用于调试目的。
			- `Clone`: 生成一个对象的副本的方法。
			- `Copy`: 允许类型通过简单的内存复制来复制其值，适用于那些没有资源所有权问题的简单类型。
			- `Hash`: 允许对象计算自己的哈希值，通常用于哈希表中。
			- `PartialEq` 和 `Eq`: 允许对象比较相等性。
			- `PartialOrd` 和 `Ord`: 允许对象进行排序和比较大小。
		- 使用 `derive` 的一个示例：
			- ```rust
			  #[derive(Debug, Clone, PartialEq)]
			  struct MyStruct {
			    a: i32,
			    b: String,
			  }
			  ```
			- 在这个例子中，`MyStruct` 将自动获得 `Debug`, `Clone`, 和 `PartialEq` traits 的实现，使你能够打印、克隆对象以及比较结构体实例是否相等。
	- ### `#[repr(...)]`
		- `repr` 属性用来控制类型的内存布局。这主要在与外部系统交互（比如 FFI - 外部函数接口，或者硬件交互），或者对性能有特殊要求时使用。
		- 下面是一些 `repr` 可以指定的内存布局：
			- `C`: 使用与 C 语言结构体相同的布局策略，这在进行 FFI 调用时非常重要。
			- `packed`: 告诉编译器尽可能地压缩结构，不进行字节对齐。
			- `u8`, `u16`, `u32`, `u64`, `usize`: 对于枚举来说，指定使用固定大小的整数来表示枚举的变体。
		- 使用 `repr` 的一个示例：
			- ```rust
			  #[repr(C)]
			  struct MyCStruct {
			    a: u32,
			    b: u8,
			  }
			  ```
			- 这里的 `MyCStruct` 会有一个和 C 语言中相同的内存布局，这对于通过 FFI 与 C 代码交互时是必需的。
	-