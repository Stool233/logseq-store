- 所有权
	- 所有权规则
		- Rust中的每一个值都有一个对应的变量作为它的所有者。
		- 在同一时间内，值有且仅有一个所有者。
		- 当所有者离开自己的作用域时，它持有的值就会被释放掉。
	- 内存与分配
		- 内存会自动地在拥有它的变量离开作用域后进行释放。
			- ![image.png](../assets/image_1679843723209_0.png){:height 129, :width 562}
			-
			- Rust在变量离开作用域时，会调用一个叫作drop的特殊函数。
				- String类型的作者可以在这个函数中编写释放内存的代码。
			- 记住，Rust会在作用域结束的地方（即}处）自动调用drop函数。
			- 注意
				- 在C++中，这种在对象生命周期结束时释放资源的模式有时也被称作资源获取即初始化（Resource Acquisition Is Initialization， RAII）。
		- 变量和数据交互的方式：移动
		- 变量和数据交互的方式：克隆
	- 所有权与函数
		- 将值传递给函数在语义上类似于对变量进行赋值。将变量传递给函数将会触发移动或复制，就像是赋值语句一样。
	- 返回值与作用域
		- 函数在返回值的过程中也会发生所有权的转移。
		- 变量所有权的转移总是遵循相同的模式：
			- 将一个值赋值给另一个变量时就会转移所有权。
			- 当一个持有堆数据的变量离开作用域时，它的数据就会被drop清理回收，除非这些数据的所有权移动到了另一个变量上。
- 引用与借用
	- 这些&代表的就是引用语义，它们允许你在不获取所有权的前提下使用值。图4-5所展示的是该过程的一个图解。
		- ![image.png](../assets/image_1679892751898_0.png){:height 333, :width 557}
		- 与使用&进行引用相反的操作被称为解引用（dereferencing），它使用*作为运算符。
	- 这里的&s1语法允许我们在不转移所有权的前提下，创建一个指向s1值的引用。由于引用不持有值的所有权，所以当引用离开当前作用域时，它指向的值也不会被丢弃。
	- 同理，函数签名中的&用来表明参数s的类型是一个引用。
		- ```rust
		  fn calculate_length(s: &String) -> usize { // s 是一个指向 String 的引用
		      s.len()
		  } // 到这里，s离开作用域。但是由于它并不持有自己所指向值的所有权，
		  //所以没有什么特殊的事情会发生
		  ```
		- 此处，变量s的有效作用域与其他任何函数参数一样，唯一不同的是，它不会在离开自己的作用域时销毁其指向的数据，因为它并不拥有该数据的所有权。
		- 当一个函数使用引用而不是值本身作为参数时，我们便不需要为了归还所有权而特意去返回值，毕竟在这种情况下，我们根本没有取得所有权。
	- 这种通过引用传递参数给函数的方法也被称为借用（borrowing）。
	- 引用的规则
		- 在任何一段给定的时间里，你要么只能拥有一个可变引用，要么只能拥有任意数量的不可变引用。
		- 引用总是有效的。
- 生命周期
	- 悬垂指针和生命周期
		- 生命周期的主要作用是避免悬垂引用，它会导致程序引用了本不该引用的数据
	- 借用检查
		- 为了保证 Rust 的所有权和借用的正确性，Rust 使用了一个借用检查器(Borrow checker)，来检查我们程序的借用正确性
-
- 在 Rust 中，`derive` 和 `repr` 是两个非常有用的属性（attributes），它们为类型提供了元数据，允许编译器执行一些自定义的行为。
	- ### `#[derive(...)]`
		- `derive` 属性用来自动为类型实现一些特定的 trait。
			- Trait 是 Rust 中的一种功能，它定义了方法的签名，这些方法可以实现为某种类型的行为。当你使用 `derive` 属性时，编译器会为你的类型生成这些方法的标准实现，而不需要你手动编写代码。
		- 下面是一些可以通过 `derive` 自动实现的常见 trait：
			- `Debug`: 允许实例通过 `println!("{:?}", instance);` 方式进行格式化打印，主要用于调试目的。
			- `Clone`: 生成一个对象的副本的方法。
			- `Copy`: 允许类型通过简单的内存复制来复制其值，适用于那些没有资源所有权问题的简单类型。
			- `Hash`: 允许对象计算自己的哈希值，通常用于哈希表中。
			- `PartialEq` 和 `Eq`: 允许对象比较相等性。
			- `PartialOrd` 和 `Ord`: 允许对象进行排序和比较大小。
		- 使用 `derive` 的一个示例：
			- ```rust
			  #[derive(Debug, Clone, PartialEq)]
			  struct MyStruct {
			    a: i32,
			    b: String,
			  }
			  ```
			- 在这个例子中，`MyStruct` 将自动获得 `Debug`, `Clone`, 和 `PartialEq` traits 的实现，使你能够打印、克隆对象以及比较结构体实例是否相等。
	- ### `#[repr(...)]`
		- `repr` 属性用来控制类型的内存布局。这主要在与外部系统交互（比如 FFI - 外部函数接口，或者硬件交互），或者对性能有特殊要求时使用。
		- 下面是一些 `repr` 可以指定的内存布局：
			- `C`: 使用与 C 语言结构体相同的布局策略，这在进行 FFI 调用时非常重要。
			- `packed`: 告诉编译器尽可能地压缩结构，不进行字节对齐。
			- `u8`, `u16`, `u32`, `u64`, `usize`: 对于枚举来说，指定使用固定大小的整数来表示枚举的变体。
		- 使用 `repr` 的一个示例：
			- ```rust
			  #[repr(C)]
			  struct MyCStruct {
			    a: u32,
			    b: u8,
			  }
			  ```
			- 这里的 `MyCStruct` 会有一个和 C 语言中相同的内存布局，这对于通过 FFI 与 C 代码交互时是必需的。
-
- 在 Rust 项目中，`lib.rs` 是一个特殊的文件，它作为库(crate)的根文件，定义了库的模块和公共接口。当你创建一个库项目时，`cargo` 工具会自动生成这个文件。
	- 库项目旨在创建可被其他项目引用的代码。与之相对的是二进制项目，它的入口是 `main.rs` 文件，并且编译后生成可执行文件。库不生成可执行文件，而是生成一个库文件（在 Linux 和 macOS 上是 `.so` 或 `.dylib` 文件，在 Windows 上是 `.dll` 文件），这个文件可以被其他 Rust 项目作为依赖来使用。
	- `lib.rs` 的作用包括：
		- **定义模块结构：** 你可以在 `lib.rs` 中声明模块，组织代码和功能。
		- **公开 API：** 你可以使用 `pub` 关键字来决定哪些函数、类型、常量、特性等是公开的，也就是说，它们可以被其他包引用和使用。
		- **重导出项（Re-exporting）：** 如果你希望库的使用者能够更容易地访问某些项，你可以在 `lib.rs` 中重导出它们。
		- **集成测试：** 虽然单元测试通常与它们测试的代码放在一起，但集成测试通常放在 `tests` 目录下，并依赖 `lib.rs` 中定义的公共 API。
-
-
- `-> &'static [u8; 1]` 指定了函数的返回类型，是对一个包含单个 `u8` 元素的静态数组的引用。`'static` 生命周期意味着这个引用在整个程序的执行期间都是有效的。
-
- `compare_exchange`
	- `compare_exchange`是 Rust 中 `Atomic` 类型提供的一个方法，它是原子操作中的一种，用于在多线程环境中安全地更新共享变量的值。`compare_exchange` 方法执行比较并交换操作，通常用于实现无锁编程中的同步模式。
	- 以下是 `compare_exchange` 方法的具体介绍：
		- 功能
			- `compare_exchange` 方法将某个原子变量的当前值与预期的值进行比较，只有在当前值与预期值相等时，才会将该变量更新为新的值。
			- 这整个过程是原子的，也就是说，比较和更新是作为一个不可分割的单元执行的，以此确保在并发程序中的一致性和原子性。
		- 参数
			- `compare_exchange` 方法通常接受以下参数：
			- `current`：预期的当前值。
			- `new`：如果当前值与预期值相等，将更新为这个新值。
			- `success`：当比较成功，即值被成功更改时，用于指定内存顺序（memory ordering）的参数。
			- `failure`：当比较失败，即值未被更改时，用于指定内存顺序的参数。
		- 内存顺序
			- 内存顺序参数控制操作的内存访问模式，对于并发程序的正确性和性能有重要影响。Rust 提供了多种内存顺序选项：
				- `Relaxed`：没有同步或顺序要求，可能会导致其他线程看到不一致的状态。
					- 这是最宽松的规则，它对编译器和 CPU 不做任何限制，可以乱序
				- `Acquire`：操作之前的读或写操作不能被重新排序到此操作之后。
					- 设定内存屏障，保证在它之后的访问永远在它之后，但是它之前的操作却有可能被重排到它后面，往往和`Release`在不同线程中联合使用
				- `Release`：操作之后的读或写操作不能被重新排序到此操作之前。
					- 设定内存屏障(Memory barrier)，保证它之前的操作永远在它之前，但是它后面的操作可能被重排到它前面
				- `AcqRel`：同时包含 `Acquire` 和 `Release` 的含义。
					- 是 *Acquire* 和 *Release* 的结合，同时拥有它们俩提供的保证。
						- 比如你要对一个 `atomic` 自增 1，同时希望该操作之前和之后的读取或写入操作不会被重新排序
				- `SeqCst`：顺序一致性，提供最强的同步保证。
			- 原则上，`Acquire`用于读取，而`Release`用于写入。
				- 但是由于有些原子操作同时拥有读取和写入的功能，此时就需要使用`AcqRel`来设置内存顺序了。
				- 在内存屏障中被写入的数据，都可以被其它线程读取到，不会有多核 CPU 缓存的问题。
				- ![image.png](../assets/image_1703262238722_0.png)
				-
		- 返回值
			- `compare_exchange` 方法的返回值是一个 `Result` 类型，其 `Ok` 变体包含先前的值，如果比较成功并更新了值，则返回 `Ok`；否则返回 `Err`，包含当时实际的当前值。
		- 使用场景
			- 在无锁数据结构中，`compare_exchange` 方法能够帮助实现多个线程对共享数据的安全访问。
			- 它特别适用于那些只有在共享数据没有被其他线程修改的情况下才需要更新的场景。
		-