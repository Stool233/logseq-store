- Fairness, Weak and Strong
	- There are two kinds of fairness: weak and strong.
		- A weakly fair action will, if it stays enabled, eventually happen.
			- We can declare every label in a process weakly fair by calling it a fair process.
		- A strongly fair action, if it’s repeatedly enabled, will eventually happen.
			- There can be gaps in between, but as long as there’s some cycle where it keeps getting enabled again, it will happen.
			- In practice, people don’t often use strong fairness; it’s a much safer to assume the system is only weakly fair.
				- However, it’s worth knowing about for the cases where it is useful.
-
- The Temporal Operators
	- []
		- [] is always.
		- []P means that for P is true for all states in all behaviors.
		- You can also write ~[]P, which means that P will be false for at least one state.
	- <>
		- <> is eventually.
		- <>P means that for every behavior, there is at least one state where P is true.
			- It may be false before, and it may be false after, but what matters is that it was at some point true.
		- You can also write ~<>P, which means that P is never true.
			- Note that this is the same as saying []~P, and in fact <>P is formally defined as ~[]~P.
	- ~>
		- ~> is leads-to. P ~> Q means that if there is some state where P is true, then either Q is true either now or in some future state.
		- Once this is set, it’s irreversible: even if P is later false, Q still must happen.
			- Unlike <>, ~> is “triggered” every time P is true.
		- You can also do P ~> []Q. If P is true, then there is some state where Q becomes true and forever stays true.
	- [ ]<> and <>[ ]
		- []<>P means that P is always eventually true, <>[]P means that P is eventually always true.
			- For a finite spec, these mean the same thing: P is true at termination.
			- For an infinite spec,
				- <>[]P means that there is some point where P becomes true and forever stays true
				- []<>P means that if P ever becomes false, it will eventually become true again.
					- Another way to think about it is that []<>P <=> (~P ~> P): P being false leads to P being true later.
-
- [[MapReduce]]
	- 三种不同假设下的形式描述
		-
		  1. A first spec that assumes all workers always succeed.（假设所有的worker都能成功。）
		-
		  id:: 6382c9cc-e87d-447e-96d1-46835002201c
		  2. A second, fault tolerant spec that allows workers to fail.（允许worker出错的容错规范。）
			- The reducer is fair. If it’s not, we can’t guarantee anything happens.
			- There is at least one fair worker. If there’s none, then we can easily see the algorithm couldn’t possible succeed: just have every worker keep crashing and you’ll never meet Liveness.
			- It doesn’t matter which worker is the fair one. This assumption significantly reduces our state space, since we can arbitrarily pick one with CHOOSE.
			- The reducer may or may not detect an unfair worker failing, but it will never falsely decide a fair worker has failed. This is the biggest assumption here, but it’s an assumption that makes our system a lot easier to design.
		-
		  3. A final spec that works even if the recovery mechanism partially fails, too.（即使恢复机制部分失败也能工作）
			- In theory, we don’t have a way of distinguishing failing nodes from passing ones. In practice, we can do things that give us a reasonable amount of confidence.
				- For example, we can ping all the servers every N seconds and assume that the ones that don’t answer in time are failing. Of course, the node might not be failing, and it could be that our reducer is acting up.
			- Before, the server could move the queue of an unfair worker to a fair one. Now, the server can still move the assignments of an unfair worker but does not know which ones are fair. Instead, it must decide which worker to pick.
				- We will continue to assume the system never reassigns away from a fair worker, as that worker always responds to the heartbeat.
				-
- While blind guessing can work for tests or typecheckers, it won’t help with specification.
-
-
- PlusCal
	- PlusCal is a language for writing algorithms. It is designed not to replace programming languages, but to replace pseudo-code.
		- Why replace pseudocode? No formal language can be as powerful or easy to write. Nothing can beat the convenience of inventing new constructs as needed and letting the reader try to deduce their meaning from informal explanations.
	-