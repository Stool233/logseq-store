- Tags: [[TLA+]]
- Fairness, Weak and Strong
	- There are two kinds of fairness: weak and strong.
		- A weakly fair action will, if it stays enabled, eventually happen.
			- We can declare every label in a process weakly fair by calling it a fair process.
		- A strongly fair action, if it’s repeatedly enabled, will eventually happen.
			- There can be gaps in between, but as long as there’s some cycle where it keeps getting enabled again, it will happen.
			- In practice, people don’t often use strong fairness; it’s a much safer to assume the system is only weakly fair.
				- However, it’s worth knowing about for the cases where it is useful.
-
- The Temporal Operators
	- []
		- [] is always.
		- []P means that for P is true for all states in all behaviors.
			- []P表示对于所有行为的所有状态P都成立。
		- You can also write ~[]P, which means that P will be false for at least one state.
			- 你也可以写~[]P，这意味着P至少在一个状态下为假。
	- <>
		- <> is eventually.
		- <>P means that for every behavior, there is at least one state where P is true.（<>P表示对于每个行为，至少有一个状态P为真。）
			- It may be false before, and it may be false after, but what matters is that it was at some point true. （它之前可能是假的，之后也可能是假的，但重要的是它在某个时刻是真的。）
		- You can also write ~<>P, which means that P is never true.（你也可以写~<>P，这意味着P永远不为真。）
			- Note that this is the same as saying []~P, and in fact <>P is formally defined as ~[]~P. （注意，这与说[]~P是一样的，事实上<>P被正式定义为~[]~P。）
	- ~>
		- ~> is leads-to. P ~> Q means that if there is some state where P is true, then either Q is true either now or in some future state.（P ~> Q意思是，如果有某个状态P为真，那么Q要么是现在为真，要么是未来为真）
		- Once this is set, it’s irreversible: even if P is later false, Q still must happen.（一旦这个设定，它是不可逆的:即使P后来为假，Q仍然必须发生。）
			- Unlike <>, ~> is “triggered” every time P is true.
		- You can also do P ~> []Q. If P is true, then there is some state where Q becomes true and forever stays true.
	- [ ]<> and <>[ ]
		- []<>P means that P is always eventually true, <>[]P means that P is eventually always true.
			- For a finite spec, these mean the same thing: P is true at termination.
			- For an infinite spec,
				- <>[]P means that there is some point where P becomes true and forever stays true
				- []<>P means that if P ever becomes false, it will eventually become true again.
					- Another way to think about it is that []<>P <=> (~P ~> P): P being false leads to P being true later.
-
- [[MapReduce]]
	- 三种不同假设下的形式描述
		- 1. A first spec that assumes all workers always succeed.（假设所有的worker都能成功。）
		- id:: 6382c9cc-e87d-447e-96d1-46835002201c
		  2. A second, fault tolerant spec that allows workers to fail.（允许worker出错的容错规范。）
			- The reducer is fair. If it’s not, we can’t guarantee anything happens.
			- There is at least one fair worker. If there’s none, then we can easily see the algorithm couldn’t possible succeed: just have every worker keep crashing and you’ll never meet Liveness.
			- It doesn’t matter which worker is the fair one. This assumption significantly reduces our state space, since we can arbitrarily pick one with CHOOSE.
			- The reducer may or may not detect an unfair worker failing, but it will never falsely decide a fair worker has failed. This is the biggest assumption here, but it’s an assumption that makes our system a lot easier to design.
		- 3. A final spec that works even if the recovery mechanism partially fails, too.（即使恢复机制部分失败也能工作）
			- In theory, we don’t have a way of distinguishing failing nodes from passing ones. In practice, we can do things that give us a reasonable amount of confidence.
				- For example, we can ping all the servers every N seconds and assume that the ones that don’t answer in time are failing. Of course, the node might not be failing, and it could be that our reducer is acting up.
			- Before, the server could move the queue of an unfair worker to a fair one. Now, the server can still move the assignments of an unfair worker but does not know which ones are fair. Instead, it must decide which worker to pick.
				- We will continue to assume the system never reassigns away from a fair worker, as that worker always responds to the heartbeat.
				-
- While blind guessing can work for tests or typecheckers, it won’t help with specification.
-
-
- PlusCal
	- PlusCal is a language for writing algorithms. It is designed not to replace programming languages, but to replace pseudo-code.
		- Why replace pseudocode? No formal language can be as powerful or easy to write. Nothing can beat the convenience of inventing new constructs as needed and letting the reader try to deduce their meaning from informal explanations.
	- The major problem with pseudo-code is that it cannot be tested, and untested code is usually incorrect.
		- In August of 2004, I did a Google search for quick sort and tested the first ten actual algorithms on the pages it found. Of those ten, four were written in pseudo-code; they were all incorrect. The only correct versions were written in executable code; they were undoubtedly correct only because they had been debugged.
	- Algorithms written in PlusCal can be tested with TLC—either by complete model checking or by repeated execution, making nondeterministic choices randomly
	- Another advantage of an algorithm written in PlusCal is that it has a precise meaning that is specified by its TLA+ translation.
		- The translation can be a practical aid to understanding the meaning of the code.
		- Since the translation is a formula of TLA, a logic with well-defined semantics and proof rules , it can be used to reason about the algorithm with any desired degree of rigor
	- PlusCal is a language with simple program structures and arbitrary mathematical expressions.
	- PlusCal is meant to replace pseudo-code. It combines the best features of pseudo-code with the ability to catch errors by model checking.
		- It is suitable for use in books, in articles, and in the classroom. It can also be used by programmers to debug their algorithms before implementing them.
-
-