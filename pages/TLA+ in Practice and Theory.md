- https://pron.github.io/posts/tlaplus_part2
	- 在第一部分中，我们讨论了TLA+设计的动机、用途以及指导原则。现在，我们将转向研究这种语言的细节。我们将从用于描述计算的静态状态的语言元素开始，即程序的数据和数据操作，这些是计算的基本构建块。我们将这部分TLA+称为数据逻辑。
	- ## **使用数学描述数据和操作**
		- TLA+采用行动的时序逻辑（TLA），来描述计算作为一个离散动态系统，这与使用常微分方程描述连续系统类似。就像常微分方程定义在一个状态空间上，其中变量可以在实数R中取值一样。TLA公式的状态空间是某种逻辑结构（我们将准确了解这意味着什么），该结构包含了TLA变量在任何时间点可以取得的值。在TLA+中，集合构成了这种结构，而描述该结构中元素的逻辑理论基于一阶逻辑和策梅洛-弗兰克尔集合论（ZFC）——普通数学的标准形式。这意味着我们将使用形式数学来描述我们的软件，或者，就目前而言，仅描述它们的数据结构和基本操作。“形式”简单地意味着在一个系统（一个“形式系统”或一个“形式体系”）中工作，该系统具有精确的规则，包括句法规则——如何构建表达式，以及语义规则——表达式的含义。
		- TLA+的这个静态组成部分占据了TLA+语言的大部分，如果你对规格语言和证明助手不熟悉，理解它将教会你在计算机上进行形式数学的所有基本知识。但从理论角度看，这是TLA+中最不有趣且最不重要的部分（TLA，动态组成部分是有趣且必需的部分），尽管从设计和可用性的角度看它很重要，因为它被设计得尽可能简单和熟悉。然而，这也是TLA+中最有争议的方面。这是因为Lamport选择了一个无类型的数学形式主义，而大多数规格语言选择了一个有类型的形式主义。
		- 除了关于正确性或生产力等指标的有争议的声明（无论是辩论的哪一方）之外，大多数人都同意编程语言中的类型具有以下优势：它们帮助编译器（特别是AOT编译器）生成高效的机器代码，并通过提供某种形式的最新文档来帮助组织代码，鼓励对子程序进行合理的关注。它们还辅助工具进行自动完成和自动重构。然而，这些较不具争议的优势对于像TLA+这样的规格语言来说并不适用，因为它不会被编译成可执行文件，而且由于规格说明的长度比程序代码短得多，因此几乎不会从旨在帮助大型程序员团队维护大型代码库的功能中受益。因此，规格语言——或一般的数学——在类型化和无类型形式主义之间的权衡与编程语言的权衡不同，这一点在Lamport和Larry Paulson（证明助手Isabelle的作者）共同且平衡的论文中有很好的覆盖，论文题为《您的规格语言应该是类型化的吗？》
		- Lamport的选择是由他对TLA+预期受众的简单性愿望（正如他所看到的）推动的，即工程师，可能还因为他作为一名经典数学家的背景。集合论具有熟悉而强大的优势，Lamport表示，他确实相信在实践中对工程师来说使用集合论来规定系统更简单。
		- 其他规格语言可能需要类型系统，因为它们用途不仅仅是软件或硬件规格的定义。Lamport写道：
			- 没有充分的理由去写一个像 {1, {2,3}} 这样的集合，而且使其无法写出似乎是个好主意。然而，我发现没有简单的方法可以做到在不同时也使有用的集合无法写出的情况下，使这样的集合无法写出。这意味着，Coq 不简单……这并不意味着 Coq 有什么问题；它只是意味着它不适用于普通工程师。例如，如果你查看一本数学文本，你可能会发现在单一段落中“+”符号被用来表示几个不同的事物。要在 TLA+ 中形式化那个数学，你必须为那些不同的含义使用不同的符号。这会让数学家感到疯狂。Coq 允许你对所有这些使用相同的符号。因此，正如 George Gonthier 将告诉你的，你需要像 Coq 这样的东西来形式化严肃的数学。由于系统构建者和算法设计师不使用那种数学，他们不需要处理像 Coq 这样的语言的复杂性。
		- TLA+ 的静态组成部分是 Lamport 称之为 ZFM 的形式集合论，ZF 代表数学中的 ZF，他在这篇短文中解释了这一点（连同与类型化形式主义的比较）。
		- 逻辑学家可能会发现 TLA+ 的形式主义太普通；甚至可能觉得枯燥。数学家 G.H. Hardy 曾经写道：“‘真正的’数学家的‘真正的’数学……几乎完全是‘无用的’……是那些乏味且基础的部分……不管好坏，都是这些起作用。”但 TLA+ 不是一个用于探索数学秘密或新颖逻辑的工具，而是一个供工程师们用来指定“有效工作”的系统的工具。就普通数学而言，TLA+ 是一个清晰、简单且强大的形式主义，具有方便自然的语法。
		- TLA+ 使用形式数学来指定软件系统。正如你将看到的，它对程序员来说并不像一开始听起来那么可怕。编程是将非正式要求转化为软件的低级形式规格——程序。如果你能够做到这一点，如果你理解为什么你的程序可以工作，或者至少，它应该如何工作，你也可以编写一个高级的数学规格。这只需要一些练习。在《指定系统》的引言中，Lamport写道：
			- 我们使用的数学比你从小接触的数学更加形式化......大多数数学家和科学家编写的数学并不是真正精确的。它在小范围内精确，但在大范围内不精确。每个方程都是一个精确的声明，但你必须阅读伴随的文字才能理解方程之间是如何相关的，以及定理的确切含义是什么。逻辑学家已经开发出了消除这些文字并使数学完全形式化的方法，因此，完全精确......[M]数学家和科学家认为没有文字的形式数学是冗长且乏味的。他们错了。普通数学可以在一个精确的、完全形式化的语言中紧凑地表达。在 DifferentialEquations 模块中定义一个任意微分方程的解只需要大约二十几行......但是很少有规格需要如此复杂的数学。大多数只需要简单应用几个标准的数学概念。
		- 我必须再次提醒你，这不是一个教程，而且覆盖的许多材料并不是编写良好的 TLA+ 规格所必需的。虽然我会介绍基础知识，并希望这篇文章中的示例能让你体验到形式数学规格是什么，以及它与编程的相似之处，但我的重点是 TLA+ 背后的数学理论和设计原则。对于 TLA+ 的好的动手教程，请参考我在第一部分中提到的那些。
	- ## **什么是逻辑？**
		- TLA+ 使用逻辑来指定算法及其数据结构。对于那些数学逻辑可能有些生疏的人来说，这里是一个复习。
		- ### 逻辑基础
			- 形式逻辑、符号逻辑或数学逻辑是一种形式系统或形式主义。它是一种精确的语言，用于讨论事物，或者至少是易于精确的事物。像任何语言一样，它具有语法，可以被视为形成句子的语法规则，以及语义或含义——语言讨论的内容。但是，作为精确的语言，它具有精确的语法和精确的语义。语法定义了如何形成语言中合法（格式良好）表达式的规则，语义通过将这些表达式与精确定义的数学对象连接起来来定义这些表达式的含义。语义使我们能确切地知道语言中任何短语的含义，语法使我们能够以这样一种方式操纵短语，即我们确切地知道其对含义的影响。
			- 逻辑的语法由一些内置的连接词组成——通常是∧表示合取（“和”），∨表示析取（“或”），¬或有时∼表示否定（“不”），⇒或→表示蕴含（“如果-那么”），≡或⇔表示等价（当且仅当，或 iff），一组变量（x，y，...）——我们用来指代对象的名称——以及一个签名，它是一组具有特定元数（符号接受的参数数量）的符号，如 5（0元），=（2元），<（2元），*（2元）或 -（一元负号）。例如，表达式 x∗5<−y∧¬(x<5) 是我举例的逻辑中的一个合法表达式。逻辑还可以有量词，最常见的是全称量词∀（“对于所有”）和存在量词∃（“存在”）。量词通常绑定变量。例如，∀x…，意味着“对于所有这样的对象 x ...”，或∃x…，意味着“存在这样的对象 x ...”。
			- 一个格式良好的表达式称为术语（语言的术语），因此语法通常被认为是所有术语的集合——语言中所有可能的格式良好的表达式。公式是一个布尔值表达式，即一个要么为真要么为假的表达式。在公式中未绑定出现的变量称为自由变量。没有自由变量的公式称为句子或封闭公式。
			- 逻辑也有一个结构，这是逻辑的论域——逻辑所讨论的内容——它为签名提供意义或语义。为逻辑分配一个特定结构称为解释。像 2 这样的 0元符号的含义通常称为常数，而高元符号的含义通常称为关系（例如，小于关系，<）或函数。变量的含义也由结构定义，尽管这里逻辑的“阶”很重要。我们稍后会讨论这个主题，但在一阶逻辑中，变量可以指结构定义的可能值的集合中的任何值；该集合被称为逻辑的宇宙。
			- 模型是语法和语义之间的关系：公式的模型是满足它的结构，即使公式为真的变量值的分配（真实是一个语义属性）。表示“满足”的通常符号是⊨。左边是使右边的公式为真的结构——公式的模型。例如，我们逻辑的结构可以是具有乘法、否定和小于关系的整数集。那么表达式 x<2 的模型可以是 x=−5。所有使公式 A 为真的模型的集合形成其正式语义，通常写作 [[A]]。我将通俗地称这些模型的集合——公式的语义——为公式的模型，并说 x<2 的模型是任何将小于 2 的数字分配给 x 的赋值，或者更简单地说，所有小于 2 的数字。我们可以说这个公式指定了所有小于二的数字。在所有解释下为真的公式被称为有效的，我们写作 ⊨A（左边没有结构）。公式 TRUE 在所有解释下都被满足，而公式 FALSE 则根本没有模型。
			- 各种逻辑运算符以特定方式与模型交互。对于 A∧B ，其模型是 A 的模型与 B 的模型的交集，即 [[A∧B]] = [[A]] ∩ [[B]]。对于 A∨B ，其模型是 A 的模型与 B 的模型的并集，即 [[A∨B]] = [[A]] ∪ [[B]]。对于 ¬A ，其模型是 A 的模型的补集，即 [[¬A]] = [[A]]^c。这些正是我们在维恩图中熟悉的逻辑运算符的定义。
			- 当我们使用逻辑时，我们通常在特定的逻辑理论中工作，该逻辑理论是一组被认为等同于 TRUE 的公式集，称为公理。一个理论的模型是满足该理论所有公理的结构；换句话说，理论描述或规定了一个模型。因此，逻辑通常不是用结构来定义的，而是用理论来定义的，这个理论随后描述了所有合适的结构。例如，皮亚诺公理就是描述自然数及其熟知的算术运算的逻辑理论。我们熟知的自然数及其算术运算，就是皮亚诺算术的一个模型。
			- 当然，一个逻辑公式，甚至整个逻辑理论，在不同的结构上可以有多种解释。例如，公式 x>2 在实数上的模型与在自然数上的模型不同。句子 ∃x.x>0∧∀y.y>0⇒y≥x 在整数上解释为真，但在实数上解释为假。
			- 逻辑通常还有一个演算系统，这是一个从其他表达式推导表达式的句法系统，如自然演绎。如果公式 C 可以通过从公式 A 和 B 应用有限次推理规则得出，我们写作 A, B⊢C，并说 A 和 B 证明了 C 或蕴含了 C，其中 A 和 B 是假设，C 是它们的结果。可证明性是语义真理概念的句法对应物。如果一个公式 A 仅由理论的公理蕴含，没有其他假设，我们写作 ⊢A，并说 A 是一个重言式。如果 ⊢A 而 A 不是一个公理，我们说 A 是一个定理。如果我们想证明定理 A 但还没有做到，我们称 A 为一个命题。
			- 根据大多数逻辑的公理，如果 A, B⊢C，那么 ⊢(A∧B)⇒C，反之亦然。即，A 和 B 蕴含或证明 C 当且仅当 A∧B 蕴含 C。
			- 有两个重要的公理塑造了逻辑的一般性质。第一个称为爆炸原理，它声明对于任何公式 A，⊢¬(A∧¬A)，或等价地 A⊢¬¬A。第二个称为排中律，它声明对于任何公式 A，⊢A∨¬A，或等价地，¬¬A⊢A。拥有这两个公理的逻辑称为经典逻辑或标准逻辑。具有爆炸原理但没有排中律的逻辑称为直觉逻辑或构造逻辑（在此逻辑中，如果 A 被知道不是假的，我们不能得出它必须是真的）。具有排中律但没有爆炸原理的逻辑称为悖论逻辑（在此逻辑中，如果 A 是真的，我们不能得出它可能也不是假的）。构造逻辑和悖论逻辑都有有趣且有用的应用。如果没有这两个公理，我们就没有办法关联否定和肯定的陈述，这相当于根本没有否定的逻辑。TLA+ 中使用的所有逻辑都是经典的。
			- 请注意，在经典逻辑中（但非经典逻辑中不是这样！），存在量词和全称量词可以通过彼此来定义：
				- ∃x.A ≡ ¬∀x.¬A
				  ∀x.A ≡ ¬∃x.¬A
				- 简而言之，我们说 ∃ ≡ ¬∀¬ 和 ∀ ≡ ¬∃¬。
			- 逻辑，就像所有语言一样，表达意义。但是逻辑陈述的意义并不总是完全通过其形式语义来捕捉。逻辑学家戈特洛布·弗雷格指出，逻辑陈述可能具有两种意义：意义和指称（后者有时也称为外延）。例如，句子 3>2 的语义值为 TRUE，因此指向值 TRUE。句子 2>1 也指向值 TRUE，因此与 3>2 等价。然而，这两个句子具有不同的意义，因为它们表达了不同的想法（一个关于 3 和 2 的关系，另一个关于 2 和 1）。意义和指称之间的区别是全面理解所有逻辑（实际上是所有语言）所需的关键哲学观察，并且某些非经典逻辑 — 特别是直觉逻辑 — 可以明确地指涉这两种意义（使用不同的等价概念，一种称为外延的，是关于指称/外延的等价，另一种称为内涵的，可以被视为关于意义的等价）。但我们只处理经典逻辑，所以这一重要的哲学观点没有实际意义。
		- ### 一阶逻辑与其他阶逻辑
			- 一阶逻辑（或称为 FOL）包含所有常规的逻辑连接词（∧, ¬ 等），以及全称量词 ∀ 和存在量词 ∃。在 FOL 中，变量可以代表宇宙中的简单值：如果宇宙是自然数，则变量——无论是自由的还是量化的，即绑定的——代表一个自然数。如果我们想要量化更丰富的结构，如自然数的集合、自然数的函数等，我们需要通过扩展我们的理论将它们加入到宇宙中。
			- 在二阶逻辑（或称为 SOL）中，一个变量可以代表宇宙中的一个元素或一组元素。将这组元素视为一个谓词比较容易；一个谓词 p(x) 为真当且仅当值 x 在集合 p 中。因此，虽然在 FOL 中所有的谓词必须是“常量”并在签名中给出，在 SOL 中我们可以量化它们，并且可以说，例如，∀1x.∃2p.∀1y.p(y)≡(y=x)（符号 ≡ 代表双向蕴含，即当且仅当，我使用下标来区分一阶和二阶量化；通常这种区分从上下文中就能明确），或用话语表达为，“对于任何 x，存在一个谓词 p，对于参数 y 为真当且仅当 y=x”。
			- 类似地，三阶逻辑允许我们量化值的集合的集合等。高阶逻辑，或称为 HOL，允许我们量化任何阶的变量，通常只在类型化的形式主义中使用。类型的最初概念是由伯特兰·罗素准确地创造出来以区分阶次：不同阶次的对象属于不同的类型，即，如果我们的“基础”值属于第一类型，则这些值的集合属于第二类型，集合的集合属于第三类型等。类型在语法上和语义上都具有重要意义：如果 x 和 y 属于不同的类型，那么表达式 x=y 不是假的，而是格式不正确的，意味着它根本不是一个合法的表达式。类似于我上面使用的下标，HOL 中的量词通过类型来区分；我们写 ∃x:T（而不是 ∃Tx），意味着“存在一个类型为 T 的 x”。
			- 逻辑中最重要的定理之一是，在一阶逻辑（仅限一阶逻辑！）中，语义真理和句法可证性是一致的，即 ⊢A 当且仅当 ⊨A，或者说，A 是重言式当且仅当它是有效的。换句话说，如果公式 A 有效——被所有解释（也满足理论的公理）满足——那么它有一个证明，反之亦然。类似地，A⊢B 当且仅当 [[A]]⊨B。这就是哥德尔的完备性定理。然而，请注意，这并不意味着一阶逻辑中的每个句子都可以被证明或反驳。如果你的理论足够丰富，总会有既不能被证明也不能被反驳的句子（在一阶逻辑的情况下，这意味着这样的理论将有多个模型，在某些模型中句子为真，在其他模型中为假）。这是另一个著名结果的后果，即哥德尔的第一不完备性定理。该定理不仅适用于一阶逻辑，而且适用于任何形式主义，因为它是停机定理的直接结果（尽管停机定理是几年后证明的）。
			- 由于 TLA+ 中的“静态”或数据逻辑和时间逻辑仅允许一阶公式，我们可以使用符号 ⊢ 来表示有效性和可证性（除非我们想特别讨论左侧的语义结构）。但是由于第一不完备性定理适用于 ZFC，因此并非每个 TLA+ 句子都可以被证明或反驳。
			- 由于 TLA+ 允许自由变量，我想指出在阅读包含蕴含（⇒）和自由变量的公式时可能会出现的混淆源：公式 x>4 ⇒ x>2 是一个定理，即 ⊢x>4 ⇒ x>2，并且所有对 x 的赋值都满足它，而 ∀x: x>4 ⇒ x>2 也是一个定理。另一方面，虽然 ∀x: x>2 ⇒ x>4 等价于 FALSE，即 ⊢¬(∀x: x>2 ⇒ x>4)，但是公式 x>2 ⇒ x>4 确实有一个模型：它被所有小于或等于2或大于4的数满足。这意味着我们必须知道我们是将 x>2 ⇒ x>4 视为一个命题——等同于询问它是否有效，或者被所有对 x 的赋值满足——在我们的案例中，这不是真的，或者不是，在这种情况下，它指定了一个模型。正如我们上面描述 A⇒B 的模型那样并不有趣，但从语义角度看，命题 ⊢A⇒B 是有意义的：⊢A⇒B 当且仅当 [[A]]⊆[[B]]。
			- 现在，请注意，一个一阶逻辑（FOL）公式的模型，例如 x>2，始终是来自宇宙的一组值（在这个例子中，是所有大于2的数字）。因此，一个FOL公式的模型始终是一个二阶对象。但是，如果一个公式的意义是一个集合，一个二阶对象，那么我们如何写一个通用的公理，例如 ⊢A∨¬A，其中A不代表一个具体的公式，而是任何公式？我们不能写 ∀A.A∨¬A，因为我们不能量化公式（正如我们刚才看到的，公式代表集合，或二阶值），也不能出于同样的原因将它们当作自由变量来处理。答案是我们不这么做。我们说这样的公理是一个公理模式，它指代逻辑中无数个公理，每个可能的公式A各一个。因此，用来写这种模式的语言不是逻辑本身，而是我们逻辑的元逻辑或元语言。
			- 从理论角度来看，这是可以的，但对于机械证明软件来说，这并不令人满意。在证明一个定理时，我们经常需要证明一些中间引理，我们希望能够陈述和证明可以在许多证明中重用的通用引理，这样的通用二阶引理可能非常有用。
			- 因此，一个解决方案是采用高阶逻辑。但保持逻辑为一阶在简单性、模型检查算法、普遍定理（如果我们知道一个公式是一阶的，更容易根据其句法结构陈述关于公式意义的定理）方面有一些优势——最后一个更适用于TLA，即TLA+的时间逻辑部分，我们将在接下来的部分中介绍。但结果表明，我们可以两者兼得。我们可以保持所有公式为一阶，但允许以 A⊢B 的形式编写二阶命题，这些命题本身不是公式（因此它们没有模型）。我们基本上提供了对元语言的访问。这是TLA+采用的解决方案，我们将在关于证明的部分后面看到。
			- 顺便提一下，因为我提到了模型检查，我想借此机会澄清关于模型检查器的某个可能的误解。模型检查器的名字来源于我们刚刚在逻辑上下文中学到的“模型”的定义。它是一个程序，接受一个逻辑结构的描述 M 和一个逻辑公式 φ，检查 M 是否是 φ 的一个模型，或者说 M⊨φ。
			- 除了一阶逻辑（FOL）的理论和实际优势外，它还有一些理论上的缺点。例如，一阶理论有非标准模型（比如，存在具有不可数多个数字的一阶皮亚诺公理的模型）。然而，鉴于TLA+的预期用途和受众，这根本不是一个问题。兰波特（Lamport）写道：“我当然不担心因为工程师实现了一个非标准的整数模型而发生错误。”
	- ## **逻辑公式和表达式**
		- 我们现在将开始学习TLA+的具体内容。如果你熟悉标准的数学符号，你会发现TLA+的语法大部分是直观且易于阅读的。然而，由于TLA+是完全形式化的，每一个表达式的含义都必须被精确定义，没有任何含糊或直觉的余地。这使得描述看起来有些过分执着，但正是这种精确性使得逻辑的机械分析成为可能。因为TLA+是无类型的，并试图模仿熟悉的非正式数学符号，尽管是以正式的方式，其细节对那些通常对证明助手感兴趣但习惯于使用类型化形式主义的人而言，可能具有特别的兴趣。
		- ### 逻辑连接词与量词
			- TLA+的静态数据逻辑是带有等式的一阶逻辑。逻辑常量是 TRUE 和 FALSE。我们使用熟悉的运算符：∧ 代表合取，∨ 代表析取，¬ 代表否定，⇒ 代表蕴含，以及 ≡ 代表等价。∧ 和 ∨ 的优先级相同，因此表达式 a∧b∨c 由于优先级不明确而是一个语法错误，需要使用括号来解决。蕴含的优先级更低，因此 A∧B⇒C 等同于 (A∧B)⇒C。
			- ∃ 和 ∀ 是常规的一阶存在量词和全称量词，用于引入绑定变量。在TLA+语法中，我们在量词后使用冒号 (:) 而不是更常见的单点，用来界定绑定变量的范围，并读作“使得”。例如：
				- ∀x: P(x)⇒∃y: R(x,y)
			- 量词绑定它们的变量在一个“尽可能远”的范围内，即直到一个闭合括号或当前表达式的末尾。因此，∀x: P(x)⇒∃x: Q(x) 是非法的，因为它被解析为 ∀x: (P(x)⇒∃x: Q(x))，因此存在量词引入了变量 x，而该变量已经绑定到全称量词。然而，(∀x: P(x))⇒∃x: Q(x) 是格式正确的。
			- 此外，TLA+还有一些受编程语言启发的特殊构造。构造
				- IF p THEN x ELSE y
			- 其中 p 是某个逻辑谓词，x 和 y 是值，如果 p 是 TRUE，则取值 x，否则取值 y。构造
				- CASE p1→e1 □ … □ pn→en □ OTHER→e
			- 等于某个 ei，该 ei 对应的 pi 为真，如果有的话，否则如果存在 OTHER 子句，则等于 e；如果不存在，表达式的值未定义（我们将在下一节详细说明这意味着什么）。更准确地说：
				- CASE p1→e1 □ … □ pn→en □ ¬(p1∨⋯∨pn)→e
			- 如果有多个谓词为真，表达式的值将是其中之一，但语言不承诺是哪一个。IF/THEN 和 CASE 都是根据我们稍后将看到的 CHOOSE 运算符定义的。
			- 由于在 TLA+ 中，算法和系统的规范是以公式的形式书写的，因此需要一些人体工程学技巧来编写长公式，使其易于阅读。Lamport 在《如何编写长公式》中设计了这样一种方案。它通过对连接词和析取词的对齐来代替括号，如下所示：
				- ```
				  \/ a
				  \/ b /\ c
				       /\ d
				  \/ e
				  ```
			- 其中 a, b, c 和 d 代表任意子公式。注意前缀连接词，它开始了析取和连接的列表。隐含的括号从开始该行的连接词后面的表达式延伸，直到在某个与开头连接词对齐的新行中遇到另一个同类型的连接词。因此，上述表示与以下表示意义相同（在 TLA+ 中也是允许的）：
				- (a)∨((b∧c)∧(d))∨(e)
			- 因此，尽管变量 x 被两个不同的量词绑定，以下形式仍然是良构的，
				- ```
				  \/ ∀ x : P(x)  
				  \/ ∃ x : Q(x)  
				  ```
			- 因为它被解析为
				- ( ∀ x : P(x) ) \\/ ( ∃ x : Q(x) )
		- ### CHOOSE运算符和未定义的含义
			- 在基本运算符的全景中，一个不可或缺的是 CHOOSE，即希尔伯特的ε（epsilon）运算符。
			- CHOOSE x: P(x) — 其中 P(x) 是可能包含 x 的某个谓词 — 等于逻辑讨论领域（即值的宇宙）中满足谓词 P 的某个值，如果存在的话。CHOOSE 遵循以下两条规则：
				- (∃x: P(x)) ≡ P(CHOOSE x: P(x))
				  (∀x: P(x) ≡ Q(x)) ⇒ (CHOOSE x: P(x)) = (CHOOSE x: Q(x))
			- 第一条规则展示了如何以 CHOOSE 来定义量词 ∃（因此也可以定义 ∀）；下一段将解释原因。
			- 第二条规则有时被称为右唯一性或外延性模式，意味着给定等效的谓词，CHOOSE 总是指定相同的值（尽管这个值不是由逻辑决定或可确定的）；尽管选择总是相同的，我们不知道也不关心它是什么，只知道它是满足谓词 P 的某个值。换句话说，CHOOSE 是确定性的，尽管具体选择不是预设的；这在新的 TLA+ 用户中是一个常见的误解。这必须如此，因为在数学中，e = e 对任何表达式 e 成立，因此，(CHOOSE x: P(x)) = (CHOOSE x: P(x)) 无论 P 是什么。
			- 如果没有任何值满足谓词 P，则 CHOOSE x: P(x) 的值是未定义的（*undefined*），这意味着它等于我们值的宇宙中的某个值（我们将在下一节遇到值，但可能的值包括 42、{3, {4, 5}} 或 "hello"），我们无法确定（即在逻辑中证明）。换句话说，“未定义”意味着“我们不知道也不关心。”虽然没有所谓未定义的“值”，但如果我们要给它标注一些符号，一个好的选择可能是 ¯_(ツ)_/¯。
			- 这个定义解释了“未定义”这一非正式概念——它可能意味着没有值——作为未指定（即，有某个值，但我们不知道是哪个）。你可能会觉得这种解释在哲学上有些困扰，但请放心，这对数学的严谨性并无影响。
			- 需要强调的是，尽管 **CHOOSE** 被命名为一个动词——我认为这对程序员来说是一个令人困惑的选择——它并不暗示任何算法，或确实任何动态的过程来找到一个值。它描述的是某物是什么，而不是如何找到它。例如 **CHOOSE x: x ∈ Int ∧ x % 2 = 0** 意味着“某个偶数整数”，而不是“找到一个偶数整数”。这种区别确实主要是哲学上的，但必须提醒程序员，此时我们只是在处理数学定义，而不是某种“运行”的算法。
			- 同样重要的是要记住，**CHOOSE** 只是选择值，它不构造值；你不能 **CHOOSE** 一个在值的宇宙中不存在的值，即其存在没有被逻辑理论的公理假设的值，这一点我将在章节“集合”中介绍。
			- TLA+ 中的 **IF/THEN/ELSE** 和 **CASE** 构造实际上是通过 **CHOOSE** 来定义的：
				- ```
				  IF p THEN e1 ELSE e2       ≜ CHOOSE v: (p ⇒ (v = e1)) ∧ (¬p ⇒ (v = e2)) 
				                             = CHOOSE v: (p ∧ (v = e1)) ∨ (¬p ∧ (v = e2))
				                       
				  CASE p1 → e1 □ … □ pn → en ≜ CHOOSE v: (p1 ∧ (v = e1)) ∨ ⋯ ∨ (pn ∧ (v = en))
				  ```
			- 我们现在可以看到 **CHOOSE** 是多么基础。我们迄今为止看到的所有 TLA+ 构造——除了命题逻辑的联结词之外的量词、**IF/THEN/ELSE** 和 **CASE**——都可以用它来定义。
			- 对于一个值未定义，不必须在其定义中使用 **CHOOSE**。正如我们将在 **CONSTANT** 部分看到的，当特定值无法通过公理和定义确定时，就可能出现未定义的值。
		- ### 定义（Definitions）
			- 定义是 TLA+ 中的主要构建块——事实上几乎是唯一的构建块，另一个则是模块，我们将在第四部分学习它。在非正式地编写定义时，数学家们使用许多不同的、希望是直观的但规定不明确的符号。另一方面，一阶逻辑的简约语言只允许我们以公理的形式编写定义，这可能会比较繁琐。例如，绝对值函数（|⋅|）在一阶逻辑中，假设解释在实数上，会像这样定义：
				- ∀x . x ≥ 0 ⇒ |x| = x
				- ∀x . x < 0 ⇒ |x| = -x
			- 在 TLA+ 中，我们可以用一种类似于熟悉的非正式符号的精确和正式的符号来编写定义。一个定义看起来是这样的：
				- Name ≜ e
			- 其中 **Name** 是我们定义的名称，**e** 是一个 TLA+ 表达式。
			- 定义可以被参数化，在这种情况下它们被称为运算符（我们稍后会讨论 TLA+ 中的数字是什么，但现在让我们假设数字和算术运算符可以使用）：
				- Double(x) ≜ 2 * x
			- 运算符不是函数；函数有其精确的含义，我们稍后将学习二者的区别。运算符可以是二阶的：
				- ApplyTwice(Op(_), x) ≜ Op(Op(x))
			- TLA+ 还支持定义一些符号运算符：
				- a ⪯ b ≜ a % b = 0
			- 与其他一些语言不同，TLA+ 只允许从预定列表的符号中定义符号运算符，其元数、位置（前缀/中缀/后缀）和优先级是固定的。我们可以为运算符参数使用符号名称，如下例中的中缀运算符：
				- Foo(x, y, _ ≺ _) ≜ IF x ≺ y THEN x ELSE y
			- 也允许递归运算符：
				- ```
				  RECURSIVE Fact(_) 
				  Fact(n) ≜ IF n ≤ 1 THEN 1 ELSE n * Fact(n - 1)
				  ```
			- 可以使用 LAMBDA 内联定义匿名运算符，如 ApplyTwice(LAMBDA x: x^2, 3)。
			- 定义的范围是其被定义的模块（我们将在第四部分学习模块），并且定义必须在其使用之前。局部于表达式的定义是用 LET..IN 构造引入的：
				- ```
				  Foo(a, b) ≜ LET x ≜ IF a ≤ b THEN a ELSE b 
				  				y ≜ x * a 
				              IN y * b
				  ```
			- LET 定义可以在任何表达式内进行。
			- 在 TLA+ 中，您不能命名已在作用范围内绑定的变量（或定义），也不允许使用与其他不同元数的运算符名称重载。
			- 名称绑定是通过顶层定义或声明引入的（我所说的声明是指我们稍后将看到的 **CONSTANT** 和 **VARIABLE** 构造），其绑定延伸到其被定义的模块的末尾，通过运算符的参数引入，其作用范围延伸到运算符定义的末尾，通过 **LET** 构造中的定义引入，其延伸到 **IN** 子句中的表达式的末尾，以及通过量化变量引入，其绑定延伸到量词作用域的末尾，如上所述。因此，以下是不允许的：
				- ```
				  x ≜ 3
				  Foo(x) ≜ x + 1
				  ```
			- 这也是不允许的：
				- ```
				  Foo(x) ≜ 
				  	LET Bar(x) ≜ x + 1 
				      IN x * 2
				  ```
			- 但以下是允许的，因为在定义 **Foo** 时 **x** 不在作用域内：
				- ```
				  Foo(x) ≜ x + 1
				  x ≜ 3
				  ```
			- 除非运算符是递归的，在这种情况下，其名称会通过 **RECURSIVE** 声明引入作用域，定义左侧的名称在定义体内尚未进入作用域。这就是为什么我们可以，而且经常写 `x ≜ CHOOSE x: P(x)`。在定义的左右两边使用相同的变量名称没有特殊意义，这等同于 `x ≜ CHOOSE z: P(z)`。
			- 逻辑的值是其结构的对象。正如我们马上会看到的，TLA+中描述算法静态数据的数据逻辑是一种集合论，因此逻辑的所有值都是集合。运算符本身不是值，我们不能对其进行量化。例如，我们不能写：
				- ```
				  ∀C, D, F : (C = D) ⇒ (F(C) = F(D))
				  ```
			- 运算符通过语法替换工作；从实际的角度来看，它们的行为类似于编程语言中的卫生宏，但它们必须计算出一个值。因此，我们不能定义以下运算符，因为 `LAMBDA` 表达式是一个运算符，不是一个值：
				- ```
				  Add(x) ≜ LAMBDA y : x + y
				  ```
			- 然而，这可以通过函数来轻松实现——在逻辑中，函数是值——我们稍后会看到。
			- 从逻辑的角度来看，运算符是二阶对象，或元语言的对象。TLA+允许将它们作为表示二阶对象的自由变量来处理，这是通过我们将在下一部分学习的 `CONSTANT` 构造以及在证明语言中实现的。因此，虽然上述使用对运算符进行量化的表达式是非法的，但其意图可以在 TLA+ 中表达，我们很快就会看到。
			- 尽管 TLA+ 被认为是无类型的，其语法不仅仅是强制其一阶逻辑的格式正确性（在拒绝形式不正确的表达式，如 `A ∧ ∧ B`）。TLA+ 还在语法上强制运算符的元数，并且使用与定义中不同数量的参数的运算符是一个语法错误。在第三部分和第四部分中，我们将看到一些通过 TLA+ 语法强制执行的更多属性，这本质上是通过类型推断机制完成的。
		- ### 自由变量和未解释变量：CONSTANT
			- 值或运算符可以在没有被定义（使用 `≜`）的情况下声明；相反，它们的含义可以通过使用公理来指定。在逻辑中，那些没有直接以其他符号定义，而是通过给定公理来确定它们如何相互作用的符号，通常被称为未解释符号。在第四部分中，我们将看到这些声明也可以被视为输入或参数，当我们学习模块和模块实例化时。
			- 在 TLA+ 中，自由变量/未解释符号使用关键字 `CONSTANT`（或其同义词 `CONSTANTS`）声明，关于它们的假设——即公理化地断言为真的公式——使用关键字 `ASSUME`（或其同义词 `AXIOM`）引入。例如，如果 `P` 和 `Q` 是一些谓词，我们可以写：
				- ```
				  CONSTANTS A, B
				  ASSUME P(A)
				  ASSUME Q(B)
				  ```
			- 假设也可以命名（`ASSUME A1 ≜ …`），以便在证明中引用它们，其中它们被视为公理。实际上，关键字 `AXIOM` 与 `ASSUME` 同义（唯一的小区别是模型检查器 TLC 检查用 `ASSUME` 声明的假设，但不检查用 `AXIOM` 声明的假设，这就是为什么 `ASSUME` 在 TLA+ 规范中更常见）。
			- 从形式逻辑的角度来看，常量只是自由变量。`P(A)` 和 `Q(B)` 是我们关于 `A` 和 `B` 所知道的全部。如果我们在定理中使用 `A`，那么我们必须证明该定理对任何满足 `P(A)` 的值 `A` 都成立。此外，`Q(A)` 或 `F(A)`（对于任何不仅仅用 `P` 定义的运算符 `F`）的值——即任何表达式的值无法从我们关于 `A` 的公理中确定——是未定义的，正如在关于 `CHOOSE` 的部分所解释的那样。
			- 尽管 `CHOOSE x : P(x)` 和 `CONSTANT x ASSUME P(x)` 在初看似乎非常不同——前者讨论某个使得 `P(x)` 成立的 `x` 的值，而后者讨论任何使得 `P(x)` 成立的 `x`——在两种情况下关于 `x` 的定理证明是相同的：我们必须证明对于所有使得 `P(x)` 成立的 `x` 都适用，因为在任何情况下我们对 `x` 除了 `P(x)` 为真之外都一无所知。然而，这两种构造在使用方式上非常不同。`CHOOSE` 可以用在任何表达式中，并使用涉及到量词或运算符参数的变量的谓词，而 `CONSTANT` 可以被实例化为特定的值（我们将在第四部分学习模块时了解如何做到这一点）。
			- 由于常量不仅可以是值，还可以是运算符，所以从技术上讲，它们是自由的二阶变量。原因是我们可以写出类似下面的内容（我们将在讨论证明时引入 `THEOREM` 构造，但它的含义在这里应该是直观的）：
			- ```
			  CONSTANTS C, D, F(_)
			  THEOREM (C = D) ⇒ (F(C) = F(D))
			  ```
			- 这个定理将 `F` 视为任何运算符，即作为一个自由变量，这相当于我们无法在 TLA+ 中编写的量化的二阶公式：
			- ```
			  ∀C, D, F : (C = D) ⇒ (F(C) = F(D))
			  ```
			- 然而，TLA+ 并没有定义这些二阶对象（即运算符）之间的等式关系。编写：
			- ```
			  CONSTANT F(_), G(_)
			  ASSUME F = G
			  ```
			- 是一个语法错误。必须编写 `ASSUME ∀x : F(x) = G(x)`。
			- 常量是 TLA+ 允许我们陈述二阶命题的一种方式，尽管它是一阶逻辑。我们将在关于证明的部分进一步讨论这个话题。
			-
			-