- https://pron.github.io/posts/tlaplus_part2
	- 在第一部分中，我们讨论了TLA+设计的动机、用途以及指导原则。现在，我们将转向研究这种语言的细节。我们将从用于描述计算的静态状态的语言元素开始，即程序的数据和数据操作，这些是计算的基本构建块。我们将这部分TLA+称为数据逻辑。
	- ## **使用数学描述数据和操作**
		- TLA+采用行动的时序逻辑（TLA），来描述计算作为一个离散动态系统，这与使用常微分方程描述连续系统类似。就像常微分方程定义在一个状态空间上，其中变量可以在实数R中取值一样。TLA公式的状态空间是某种逻辑结构（我们将准确了解这意味着什么），该结构包含了TLA变量在任何时间点可以取得的值。在TLA+中，集合构成了这种结构，而描述该结构中元素的逻辑理论基于一阶逻辑和策梅洛-弗兰克尔集合论（ZFC）——普通数学的标准形式。这意味着我们将使用形式数学来描述我们的软件，或者，就目前而言，仅描述它们的数据结构和基本操作。“形式”简单地意味着在一个系统（一个“形式系统”或一个“形式体系”）中工作，该系统具有精确的规则，包括句法规则——如何构建表达式，以及语义规则——表达式的含义。
		- TLA+的这个静态组成部分占据了TLA+语言的大部分，如果你对规格语言和证明助手不熟悉，理解它将教会你在计算机上进行形式数学的所有基本知识。但从理论角度看，这是TLA+中最不有趣且最不重要的部分（TLA，动态组成部分是有趣且必需的部分），尽管从设计和可用性的角度看它很重要，因为它被设计得尽可能简单和熟悉。然而，这也是TLA+中最有争议的方面。这是因为Lamport选择了一个无类型的数学形式主义，而大多数规格语言选择了一个有类型的形式主义。
		- 除了关于正确性或生产力等指标的有争议的声明（无论是辩论的哪一方）之外，大多数人都同意编程语言中的类型具有以下优势：它们帮助编译器（特别是AOT编译器）生成高效的机器代码，并通过提供某种形式的最新文档来帮助组织代码，鼓励对子程序进行合理的关注。它们还辅助工具进行自动完成和自动重构。然而，这些较不具争议的优势对于像TLA+这样的规格语言来说并不适用，因为它不会被编译成可执行文件，而且由于规格说明的长度比程序代码短得多，因此几乎不会从旨在帮助大型程序员团队维护大型代码库的功能中受益。因此，规格语言——或一般的数学——在类型化和无类型形式主义之间的权衡与编程语言的权衡不同，这一点在Lamport和Larry Paulson（证明助手Isabelle的作者）共同且平衡的论文中有很好的覆盖，论文题为《您的规格语言应该是类型化的吗？》
		- Lamport的选择是由他对TLA+预期受众的简单性愿望（正如他所看到的）推动的，即工程师，可能还因为他作为一名经典数学家的背景。集合论具有熟悉而强大的优势，Lamport表示，他确实相信在实践中对工程师来说使用集合论来规定系统更简单。
		- 其他规格语言可能需要类型系统，因为它们用途不仅仅是软件或硬件规格的定义。Lamport写道：
			- 没有充分的理由去写一个像 {1, {2,3}} 这样的集合，而且使其无法写出似乎是个好主意。然而，我发现没有简单的方法可以做到在不同时也使有用的集合无法写出的情况下，使这样的集合无法写出。这意味着，Coq 不简单……这并不意味着 Coq 有什么问题；它只是意味着它不适用于普通工程师。例如，如果你查看一本数学文本，你可能会发现在单一段落中“+”符号被用来表示几个不同的事物。要在 TLA+ 中形式化那个数学，你必须为那些不同的含义使用不同的符号。这会让数学家感到疯狂。Coq 允许你对所有这些使用相同的符号。因此，正如 George Gonthier 将告诉你的，你需要像 Coq 这样的东西来形式化严肃的数学。由于系统构建者和算法设计师不使用那种数学，他们不需要处理像 Coq 这样的语言的复杂性。
		- TLA+ 的静态组成部分是 Lamport 称之为 ZFM 的形式集合论，ZF 代表数学中的 ZF，他在这篇短文中解释了这一点（连同与类型化形式主义的比较）。
		- 逻辑学家可能会发现 TLA+ 的形式主义太普通；甚至可能觉得枯燥。数学家 G.H. Hardy 曾经写道：“‘真正的’数学家的‘真正的’数学……几乎完全是‘无用的’……是那些乏味且基础的部分……不管好坏，都是这些起作用。”但 TLA+ 不是一个用于探索数学秘密或新颖逻辑的工具，而是一个供工程师们用来指定“有效工作”的系统的工具。就普通数学而言，TLA+ 是一个清晰、简单且强大的形式主义，具有方便自然的语法。
		- TLA+ 使用形式数学来指定软件系统。正如你将看到的，它对程序员来说并不像一开始听起来那么可怕。编程是将非正式要求转化为软件的低级形式规格——程序。如果你能够做到这一点，如果你理解为什么你的程序可以工作，或者至少，它应该如何工作，你也可以编写一个高级的数学规格。这只需要一些练习。在《指定系统》的引言中，Lamport写道：
			- 我们使用的数学比你从小接触的数学更加形式化......大多数数学家和科学家编写的数学并不是真正精确的。它在小范围内精确，但在大范围内不精确。每个方程都是一个精确的声明，但你必须阅读伴随的文字才能理解方程之间是如何相关的，以及定理的确切含义是什么。逻辑学家已经开发出了消除这些文字并使数学完全形式化的方法，因此，完全精确......[M]数学家和科学家认为没有文字的形式数学是冗长且乏味的。他们错了。普通数学可以在一个精确的、完全形式化的语言中紧凑地表达。在 DifferentialEquations 模块中定义一个任意微分方程的解只需要大约二十几行......但是很少有规格需要如此复杂的数学。大多数只需要简单应用几个标准的数学概念。
		- 我必须再次提醒你，这不是一个教程，而且覆盖的许多材料并不是编写良好的 TLA+ 规格所必需的。虽然我会介绍基础知识，并希望这篇文章中的示例能让你体验到形式数学规格是什么，以及它与编程的相似之处，但我的重点是 TLA+ 背后的数学理论和设计原则。对于 TLA+ 的好的动手教程，请参考我在第一部分中提到的那些。
	- ## **什么是逻辑？**
		- TLA+ 使用逻辑来指定算法及其数据结构。对于那些数学逻辑可能有些生疏的人来说，这里是一个复习。
		- ### 逻辑基础
			- 形式逻辑、符号逻辑或数学逻辑是一种形式系统或形式主义。它是一种精确的语言，用于讨论事物，或者至少是易于精确的事物。像任何语言一样，它具有语法，可以被视为形成句子的语法规则，以及语义或含义——语言讨论的内容。但是，作为精确的语言，它具有精确的语法和精确的语义。语法定义了如何形成语言中合法（格式良好）表达式的规则，语义通过将这些表达式与精确定义的数学对象连接起来来定义这些表达式的含义。语义使我们能确切地知道语言中任何短语的含义，语法使我们能够以这样一种方式操纵短语，即我们确切地知道其对含义的影响。
			- 逻辑的语法由一些内置的连接词组成——通常是∧表示合取（“和”），∨表示析取（“或”），¬或有时∼表示否定（“不”），⇒或→表示蕴含（“如果-那么”），≡或⇔表示等价（当且仅当，或 iff），一组变量（x，y，...）——我们用来指代对象的名称——以及一个签名，它是一组具有特定元数（符号接受的参数数量）的符号，如 5（0元），=（2元），<（2元），*（2元）或 -（一元负号）。例如，表达式 x∗5<−y∧¬(x<5) 是我举例的逻辑中的一个合法表达式。逻辑还可以有量词，最常见的是全称量词∀（“对于所有”）和存在量词∃（“存在”）。量词通常绑定变量。例如，∀x…，意味着“对于所有这样的对象 x ...”，或∃x…，意味着“存在这样的对象 x ...”。
			- 一个格式良好的表达式称为术语（语言的术语），因此语法通常被认为是所有术语的集合——语言中所有可能的格式良好的表达式。公式是一个布尔值表达式，即一个要么为真要么为假的表达式。在公式中未绑定出现的变量称为自由变量。没有自由变量的公式称为句子或封闭公式。
			- 逻辑也有一个结构，这是逻辑的论域——逻辑所讨论的内容——它为签名提供意义或语义。为逻辑分配一个特定结构称为解释。像 2 这样的 0元符号的含义通常称为常数，而高元符号的含义通常称为关系（例如，小于关系，<）或函数。变量的含义也由结构定义，尽管这里逻辑的“阶”很重要。我们稍后会讨论这个主题，但在一阶逻辑中，变量可以指结构定义的可能值的集合中的任何值；该集合被称为逻辑的宇宙。
			- 模型是语法和语义之间的关系：公式的模型是满足它的结构，即使公式为真的变量值的分配（真实是一个语义属性）。表示“满足”的通常符号是⊨。左边是使右边的公式为真的结构——公式的模型。例如，我们逻辑的结构可以是具有乘法、否定和小于关系的整数集。那么表达式 x<2 的模型可以是 x=−5。所有使公式 A 为真的模型的集合形成其正式语义，通常写作 [[A]]。我将通俗地称这些模型的集合——公式的语义——为公式的模型，并说 x<2 的模型是任何将小于 2 的数字分配给 x 的赋值，或者更简单地说，所有小于 2 的数字。我们可以说这个公式指定了所有小于二的数字。在所有解释下为真的公式被称为有效的，我们写作 ⊨A（左边没有结构）。公式 TRUE 在所有解释下都被满足，而公式 FALSE 则根本没有模型。
			- 各种逻辑运算符以特定方式与模型交互。对于 A∧B ，其模型是 A 的模型与 B 的模型的交集，即 [[A∧B]] = [[A]] ∩ [[B]]。对于 A∨B ，其模型是 A 的模型与 B 的模型的并集，即 [[A∨B]] = [[A]] ∪ [[B]]。对于 ¬A ，其模型是 A 的模型的补集，即 [[¬A]] = [[A]]^c。这些正是我们在维恩图中熟悉的逻辑运算符的定义。
			- 当我们使用逻辑时，我们通常在特定的逻辑理论中工作，该逻辑理论是一组被认为等同于 TRUE 的公式集，称为公理。一个理论的模型是满足该理论所有公理的结构；换句话说，理论描述或规定了一个模型。因此，逻辑通常不是用结构来定义的，而是用理论来定义的，这个理论随后描述了所有合适的结构。例如，皮亚诺公理就是描述自然数及其熟知的算术运算的逻辑理论。我们熟知的自然数及其算术运算，就是皮亚诺算术的一个模型。
			- 当然，一个逻辑公式，甚至整个逻辑理论，在不同的结构上可以有多种解释。例如，公式 x>2 在实数上的模型与在自然数上的模型不同。句子 ∃x.x>0∧∀y.y>0⇒y≥x 在整数上解释为真，但在实数上解释为假。
			- 逻辑通常还有一个演算系统，这是一个从其他表达式推导表达式的句法系统，如自然演绎。如果公式 C 可以通过从公式 A 和 B 应用有限次推理规则得出，我们写作 A, B⊢C，并说 A 和 B 证明了 C 或蕴含了 C，其中 A 和 B 是假设，C 是它们的结果。可证明性是语义真理概念的句法对应物。如果一个公式 A 仅由理论的公理蕴含，没有其他假设，我们写作 ⊢A，并说 A 是一个重言式。如果 ⊢A 而 A 不是一个公理，我们说 A 是一个定理。如果我们想证明定理 A 但还没有做到，我们称 A 为一个命题。
			- 根据大多数逻辑的公理，如果 A, B⊢C，那么 ⊢(A∧B)⇒C，反之亦然。即，A 和 B 蕴含或证明 C 当且仅当 A∧B 蕴含 C。
			- 有两个重要的公理塑造了逻辑的一般性质。第一个称为爆炸原理，它声明对于任何公式 A，⊢¬(A∧¬A)，或等价地 A⊢¬¬A。第二个称为排中律，它声明对于任何公式 A，⊢A∨¬A，或等价地，¬¬A⊢A。拥有这两个公理的逻辑称为经典逻辑或标准逻辑。具有爆炸原理但没有排中律的逻辑称为直觉逻辑或构造逻辑（在此逻辑中，如果 A 被知道不是假的，我们不能得出它必须是真的）。具有排中律但没有爆炸原理的逻辑称为悖论逻辑（在此逻辑中，如果 A 是真的，我们不能得出它可能也不是假的）。构造逻辑和悖论逻辑都有有趣且有用的应用。如果没有这两个公理，我们就没有办法关联否定和肯定的陈述，这相当于根本没有否定的逻辑。TLA+ 中使用的所有逻辑都是经典的。
			- 请注意，在经典逻辑中（但非经典逻辑中不是这样！），存在量词和全称量词可以通过彼此来定义：
				- ∃x.A ≡ ¬∀x.¬A
				  ∀x.A ≡ ¬∃x.¬A
				- 简而言之，我们说 ∃ ≡ ¬∀¬ 和 ∀ ≡ ¬∃¬。
			- 逻辑，就像所有语言一样，表达意义。但是逻辑陈述的意义并不总是完全通过其形式语义来捕捉。逻辑学家戈特洛布·弗雷格指出，逻辑陈述可能具有两种意义：意义和指称（后者有时也称为外延）。例如，句子 3>2 的语义值为 TRUE，因此指向值 TRUE。句子 2>1 也指向值 TRUE，因此与 3>2 等价。然而，这两个句子具有不同的意义，因为它们表达了不同的想法（一个关于 3 和 2 的关系，另一个关于 2 和 1）。意义和指称之间的区别是全面理解所有逻辑（实际上是所有语言）所需的关键哲学观察，并且某些非经典逻辑 — 特别是直觉逻辑 — 可以明确地指涉这两种意义（使用不同的等价概念，一种称为外延的，是关于指称/外延的等价，另一种称为内涵的，可以被视为关于意义的等价）。但我们只处理经典逻辑，所以这一重要的哲学观点没有实际意义。
		- ### 一阶逻辑与其他阶逻辑
			- 一阶逻辑（或称为 FOL）包含所有常规的逻辑连接词（∧, ¬ 等），以及全称量词 ∀ 和存在量词 ∃。在 FOL 中，变量可以代表宇宙中的简单值：如果宇宙是自然数，则变量——无论是自由的还是量化的，即绑定的——代表一个自然数。如果我们想要量化更丰富的结构，如自然数的集合、自然数的函数等，我们需要通过扩展我们的理论将它们加入到宇宙中。
			- 在二阶逻辑（或称为 SOL）中，一个变量可以代表宇宙中的一个元素或一组元素。将这组元素视为一个谓词比较容易；一个谓词 p(x) 为真当且仅当值 x 在集合 p 中。因此，虽然在 FOL 中所有的谓词必须是“常量”并在签名中给出，在 SOL 中我们可以量化它们，并且可以说，例如，∀1x.∃2p.∀1y.p(y)≡(y=x)（符号 ≡ 代表双向蕴含，即当且仅当，我使用下标来区分一阶和二阶量化；通常这种区分从上下文中就能明确），或用话语表达为，“对于任何 x，存在一个谓词 p，对于参数 y 为真当且仅当 y=x”。
			- 类似地，三阶逻辑允许我们量化值的集合的集合等。高阶逻辑，或称为 HOL，允许我们量化任何阶的变量，通常只在类型化的形式主义中使用。类型的最初概念是由伯特兰·罗素准确地创造出来以区分阶次：不同阶次的对象属于不同的类型，即，如果我们的“基础”值属于第一类型，则这些值的集合属于第二类型，集合的集合属于第三类型等。类型在语法上和语义上都具有重要意义：如果 x 和 y 属于不同的类型，那么表达式 x=y 不是假的，而是格式不正确的，意味着它根本不是一个合法的表达式。类似于我上面使用的下标，HOL 中的量词通过类型来区分；我们写 ∃x:T（而不是 ∃Tx），意味着“存在一个类型为 T 的 x”。
			- 逻辑中最重要的定理之一是，在一阶逻辑（仅限一阶逻辑！）中，语义真理和句法可证性是一致的，即 ⊢A 当且仅当 ⊨A，或者说，A 是重言式当且仅当它是有效的。换句话说，如果公式 A 有效——被所有解释（也满足理论的公理）满足——那么它有一个证明，反之亦然。类似地，A⊢B 当且仅当 [[A]]⊨B。这就是哥德尔的完备性定理。然而，请注意，这并不意味着一阶逻辑中的每个句子都可以被证明或反驳。如果你的理论足够丰富，总会有既不能被证明也不能被反驳的句子（在一阶逻辑的情况下，这意味着这样的理论将有多个模型，在某些模型中句子为真，在其他模型中为假）。这是另一个著名结果的后果，即哥德尔的第一不完备性定理。该定理不仅适用于一阶逻辑，而且适用于任何形式主义，因为它是停机定理的直接结果（尽管停机定理是几年后证明的）。
			- 由于 TLA+ 中的“静态”或数据逻辑和时间逻辑仅允许一阶公式，我们可以使用符号 ⊢ 来表示有效性和可证性（除非我们想特别讨论左侧的语义结构）。但是由于第一不完备性定理适用于 ZFC，因此并非每个 TLA+ 句子都可以被证明或反驳。
			- 由于 TLA+ 允许自由变量，我想指出在阅读包含蕴含（⇒）和自由变量的公式时可能会出现的混淆源：公式 x>4 ⇒ x>2 是一个定理，即 ⊢x>4 ⇒ x>2，并且所有对 x 的赋值都满足它，而 ∀x: x>4 ⇒ x>2 也是一个定理。另一方面，虽然 ∀x: x>2 ⇒ x>4 等价于 FALSE，即 ⊢¬(∀x: x>2 ⇒ x>4)，但是公式 x>2 ⇒ x>4 确实有一个模型：它被所有小于或等于2或大于4的数满足。这意味着我们必须知道我们是将 x>2 ⇒ x>4 视为一个命题——等同于询问它是否有效，或者被所有对 x 的赋值满足——在我们的案例中，这不是真的，或者不是，在这种情况下，它指定了一个模型。正如我们上面描述 A⇒B 的模型那样并不有趣，但从语义角度看，命题 ⊢A⇒B 是有意义的：⊢A⇒B 当且仅当 [[A]]⊆[[B]]。
			- 现在，请注意，一个一阶逻辑（FOL）公式的模型，例如 x>2，始终是来自宇宙的一组值（在这个例子中，是所有大于2的数字）。因此，一个FOL公式的模型始终是一个二阶对象。但是，如果一个公式的意义是一个集合，一个二阶对象，那么我们如何写一个通用的公理，例如 ⊢A∨¬A，其中A不代表一个具体的公式，而是任何公式？我们不能写 ∀A.A∨¬A，因为我们不能量化公式（正如我们刚才看到的，公式代表集合，或二阶值），也不能出于同样的原因将它们当作自由变量来处理。答案是我们不这么做。我们说这样的公理是一个公理模式，它指代逻辑中无数个公理，每个可能的公式A各一个。因此，用来写这种模式的语言不是逻辑本身，而是我们逻辑的元逻辑或元语言。
			- 从理论角度来看，这是可以的，但对于机械证明软件来说，这并不令人满意。在证明一个定理时，我们经常需要证明一些中间引理，我们希望能够陈述和证明可以在许多证明中重用的通用引理，这样的通用二阶引理可能非常有用。
			- 因此，一个解决方案是采用高阶逻辑。但保持逻辑为一阶在简单性、模型检查算法、普遍定理（如果我们知道一个公式是一阶的，更容易根据其句法结构陈述关于公式意义的定理）方面有一些优势——最后一个更适用于TLA，即TLA+的时间逻辑部分，我们将在接下来的部分中介绍。但结果表明，我们可以两者兼得。我们可以保持所有公式为一阶，但允许以 A⊢B 的形式编写二阶命题，这些命题本身不是公式（因此它们没有模型）。我们基本上提供了对元语言的访问。这是TLA+采用的解决方案，我们将在关于证明的部分后面看到。
			- 顺便提一下，因为我提到了模型检查，我想借此机会澄清关于模型检查器的某个可能的误解。模型检查器的名字来源于我们刚刚在逻辑上下文中学到的“模型”的定义。它是一个程序，接受一个逻辑结构的描述 M 和一个逻辑公式 φ，检查 M 是否是 φ 的一个模型，或者说 M⊨φ。
			- 除了一阶逻辑（FOL）的理论和实际优势外，它还有一些理论上的缺点。例如，一阶理论有非标准模型（比如，存在具有不可数多个数字的一阶皮亚诺公理的模型）。然而，鉴于TLA+的预期用途和受众，这根本不是一个问题。兰波特（Lamport）写道：“我当然不担心因为工程师实现了一个非标准的整数模型而发生错误。”
	- ## **逻辑公式和表达式**
		- 我们现在将开始学习TLA+的具体内容。如果你熟悉标准的数学符号，你会发现TLA+的语法大部分是直观且易于阅读的。然而，由于TLA+是完全形式化的，每一个表达式的含义都必须被精确定义，没有任何含糊或直觉的余地。这使得描述看起来有些过分执着，但正是这种精确性使得逻辑的机械分析成为可能。因为TLA+是无类型的，并试图模仿熟悉的非正式数学符号，尽管是以正式的方式，其细节对那些通常对证明助手感兴趣但习惯于使用类型化形式主义的人而言，可能具有特别的兴趣。
		- ### 逻辑连接词与量词
			- TLA+的静态数据逻辑是带有等式的一阶逻辑。逻辑常量是 TRUE 和 FALSE。我们使用熟悉的运算符：∧ 代表合取，∨ 代表析取，¬ 代表否定，⇒ 代表蕴含，以及 ≡ 代表等价。∧ 和 ∨ 的优先级相同，因此表达式 a∧b∨c 由于优先级不明确而是一个语法错误，需要使用括号来解决。蕴含的优先级更低，因此 A∧B⇒C 等同于 (A∧B)⇒C。
			- ∃ 和 ∀ 是常规的一阶存在量词和全称量词，用于引入绑定变量。在TLA+语法中，我们在量词后使用冒号 (:) 而不是更常见的单点，用来界定绑定变量的范围，并读作“使得”。例如：
				- ∀x: P(x)⇒∃y: R(x,y)
			- 量词绑定它们的变量在一个“尽可能远”的范围内，即直到一个闭合括号或当前表达式的末尾。因此，∀x: P(x)⇒∃x: Q(x) 是非法的，因为它被解析为 ∀x: (P(x)⇒∃x: Q(x))，因此存在量词引入了变量 x，而该变量已经绑定到全称量词。然而，(∀x: P(x))⇒∃x: Q(x) 是格式正确的。
			- 此外，TLA+还有一些受编程语言启发的特殊构造。构造
				- IF p THEN x ELSE y
			- 其中 p 是某个逻辑谓词，x 和 y 是值，如果 p 是 TRUE，则取值 x，否则取值 y。构造
				- CASE p1→e1 □ … □ pn→en □ OTHER→e
			- 等于某个 ei，该 ei 对应的 pi 为真，如果有的话，否则如果存在 OTHER 子句，则等于 e；如果不存在，表达式的值未定义（我们将在下一节详细说明这意味着什么）。更准确地说：
				- CASE p1→e1 □ … □ pn→en □ ¬(p1∨⋯∨pn)→e
			- 如果有多个谓词为真，表达式的值将是其中之一，但语言不承诺是哪一个。IF/THEN 和 CASE 都是根据我们稍后将看到的 CHOOSE 运算符定义的。
			- 由于在 TLA+ 中，算法和系统的规范是以公式的形式书写的，因此需要一些人体工程学技巧来编写长公式，使其易于阅读。Lamport 在《如何编写长公式》中设计了这样一种方案。它通过对连接词和析取词的对齐来代替括号，如下所示：
				- ```
				  \/ a
				  \/ b /\ c
				       /\ d
				  \/ e
				  ```
			- 其中 a, b, c 和 d 代表任意子公式。注意前缀连接词，它开始了析取和连接的列表。隐含的括号从开始该行的连接词后面的表达式延伸，直到在某个与开头连接词对齐的新行中遇到另一个同类型的连接词。因此，上述表示与以下表示意义相同（在 TLA+ 中也是允许的）：
				- (a)∨((b∧c)∧(d))∨(e)
			- 因此，尽管变量 x 被两个不同的量词绑定，以下形式仍然是良构的，
				- ```
				  \/ ∀ x : P(x)  
				  \/ ∃ x : Q(x)  
				  ```
			- 因为它被解析为
				- ( ∀ x : P(x) ) \\/ ( ∃ x : Q(x) )
		- ### CHOOSE运算符和未定义的含义
			- 在基本运算符的全景中，一个不可或缺的是 CHOOSE，即希尔伯特的ε（epsilon）运算符。
			- CHOOSE x: P(x) — 其中 P(x) 是可能包含 x 的某个谓词 — 等于逻辑讨论领域（即值的宇宙）中满足谓词 P 的某个值，如果存在的话。CHOOSE 遵循以下两条规则：
				- (∃x: P(x)) ≡ P(CHOOSE x: P(x))
				  (∀x: P(x) ≡ Q(x)) ⇒ (CHOOSE x: P(x)) = (CHOOSE x: Q(x))
			- 第一条规则展示了如何以 CHOOSE 来定义量词 ∃（因此也可以定义 ∀）；下一段将解释原因。
			- 第二条规则有时被称为右唯一性或外延性模式，意味着给定等效的谓词，CHOOSE 总是指定相同的值（尽管这个值不是由逻辑决定或可确定的）；尽管选择总是相同的，我们不知道也不关心它是什么，只知道它是满足谓词 P 的某个值。换句话说，CHOOSE 是确定性的，尽管具体选择不是预设的；这在新的 TLA+ 用户中是一个常见的误解。这必须如此，因为在数学中，e = e 对任何表达式 e 成立，因此，(CHOOSE x: P(x)) = (CHOOSE x: P(x)) 无论 P 是什么。
			- 如果没有任何值满足谓词 P，则 CHOOSE x: P(x) 的值是未定义的（*undefined*），这意味着它等于我们值的宇宙中的某个值（我们将在下一节遇到值，但可能的值包括 42、{3, {4, 5}} 或 "hello"），我们无法确定（即在逻辑中证明）。换句话说，“未定义”意味着“我们不知道也不关心。”虽然没有所谓未定义的“值”，但如果我们要给它标注一些符号，一个好的选择可能是 ¯_(ツ)_/¯。
			- 这个定义解释了“未定义”这一非正式概念——它可能意味着没有值——作为未指定（即，有某个值，但我们不知道是哪个）。你可能会觉得这种解释在哲学上有些困扰，但请放心，这对数学的严谨性并无影响。
			- 需要强调的是，尽管 **CHOOSE** 被命名为一个动词——我认为这对程序员来说是一个令人困惑的选择——它并不暗示任何算法，或确实任何动态的过程来找到一个值。它描述的是某物是什么，而不是如何找到它。例如 **CHOOSE x: x ∈ Int ∧ x % 2 = 0** 意味着“某个偶数整数”，而不是“找到一个偶数整数”。这种区别确实主要是哲学上的，但必须提醒程序员，此时我们只是在处理数学定义，而不是某种“运行”的算法。
			- 同样重要的是要记住，**CHOOSE** 只是选择值，它不构造值；你不能 **CHOOSE** 一个在值的宇宙中不存在的值，即其存在没有被逻辑理论的公理假设的值，这一点我将在章节“集合”中介绍。
			- TLA+ 中的 **IF/THEN/ELSE** 和 **CASE** 构造实际上是通过 **CHOOSE** 来定义的：
				- ```
				  IF p THEN e1 ELSE e2       ≜ CHOOSE v: (p ⇒ (v = e1)) ∧ (¬p ⇒ (v = e2)) 
				                             = CHOOSE v: (p ∧ (v = e1)) ∨ (¬p ∧ (v = e2))
				                       
				  CASE p1 → e1 □ … □ pn → en ≜ CHOOSE v: (p1 ∧ (v = e1)) ∨ ⋯ ∨ (pn ∧ (v = en))
				  ```
			- 我们现在可以看到 **CHOOSE** 是多么基础。我们迄今为止看到的所有 TLA+ 构造——除了命题逻辑的联结词之外的量词、**IF/THEN/ELSE** 和 **CASE**——都可以用它来定义。
			- 对于一个值未定义，不必须在其定义中使用 **CHOOSE**。正如我们将在 **CONSTANT** 部分看到的，当特定值无法通过公理和定义确定时，就可能出现未定义的值。
		- ### 定义（Definitions）
			- 定义是 TLA+ 中的主要构建块——事实上几乎是唯一的构建块，另一个则是模块，我们将在第四部分学习它。在非正式地编写定义时，数学家们使用许多不同的、希望是直观的但规定不明确的符号。另一方面，一阶逻辑的简约语言只允许我们以公理的形式编写定义，这可能会比较繁琐。例如，绝对值函数（|⋅|）在一阶逻辑中，假设解释在实数上，会像这样定义：
				- ∀x . x ≥ 0 ⇒ |x| = x
				- ∀x . x < 0 ⇒ |x| = -x
			- 在 TLA+ 中，我们可以用一种类似于熟悉的非正式符号的精确和正式的符号来编写定义。一个定义看起来是这样的：
				- Name ≜ e
			- 其中 **Name** 是我们定义的名称，**e** 是一个 TLA+ 表达式。
			- 定义可以被参数化，在这种情况下它们被称为运算符（我们稍后会讨论 TLA+ 中的数字是什么，但现在让我们假设数字和算术运算符可以使用）：
				- Double(x) ≜ 2 * x
			- 运算符不是函数；函数有其精确的含义，我们稍后将学习二者的区别。运算符可以是二阶的：
				- ApplyTwice(Op(_), x) ≜ Op(Op(x))
			- TLA+ 还支持定义一些符号运算符：
				- a ⪯ b ≜ a % b = 0
			- 与其他一些语言不同，TLA+ 只允许从预定列表的符号中定义符号运算符，其元数、位置（前缀/中缀/后缀）和优先级是固定的。我们可以为运算符参数使用符号名称，如下例中的中缀运算符：
				- Foo(x, y, _ ≺ _) ≜ IF x ≺ y THEN x ELSE y
			- 也允许递归运算符：
				- ```
				  RECURSIVE Fact(_) 
				  Fact(n) ≜ IF n ≤ 1 THEN 1 ELSE n * Fact(n - 1)
				  ```
			- 可以使用 LAMBDA 内联定义匿名运算符，如 ApplyTwice(LAMBDA x: x^2, 3)。
			- 定义的范围是其被定义的模块（我们将在第四部分学习模块），并且定义必须在其使用之前。局部于表达式的定义是用 LET..IN 构造引入的：
				- ```
				  Foo(a, b) ≜ LET x ≜ IF a ≤ b THEN a ELSE b 
				  				y ≜ x * a 
				              IN y * b
				  ```
			- LET 定义可以在任何表达式内进行。
			- 在 TLA+ 中，您不能命名已在作用范围内绑定的变量（或定义），也不允许使用与其他不同元数的运算符名称重载。
			- 名称绑定是通过顶层定义或声明引入的（我所说的声明是指我们稍后将看到的 **CONSTANT** 和 **VARIABLE** 构造），其绑定延伸到其被定义的模块的末尾，通过运算符的参数引入，其作用范围延伸到运算符定义的末尾，通过 **LET** 构造中的定义引入，其延伸到 **IN** 子句中的表达式的末尾，以及通过量化变量引入，其绑定延伸到量词作用域的末尾，如上所述。因此，以下是不允许的：
				- ```
				  x ≜ 3
				  Foo(x) ≜ x + 1
				  ```
			- 这也是不允许的：
				- ```
				  Foo(x) ≜ 
				  	LET Bar(x) ≜ x + 1 
				      IN x * 2
				  ```
			- 但以下是允许的，因为在定义 **Foo** 时 **x** 不在作用域内：
				- ```
				  Foo(x) ≜ x + 1
				  x ≜ 3
				  ```
			- 除非运算符是递归的，在这种情况下，其名称会通过 **RECURSIVE** 声明引入作用域，定义左侧的名称在定义体内尚未进入作用域。这就是为什么我们可以，而且经常写 `x ≜ CHOOSE x: P(x)`。在定义的左右两边使用相同的变量名称没有特殊意义，这等同于 `x ≜ CHOOSE z: P(z)`。
			- 逻辑的值是其结构的对象。正如我们马上会看到的，TLA+中描述算法静态数据的数据逻辑是一种集合论，因此逻辑的所有值都是集合。运算符本身不是值，我们不能对其进行量化。例如，我们不能写：
				- ```
				  ∀C, D, F : (C = D) ⇒ (F(C) = F(D))
				  ```
			- 运算符通过语法替换工作；从实际的角度来看，它们的行为类似于编程语言中的卫生宏，但它们必须计算出一个值。因此，我们不能定义以下运算符，因为 `LAMBDA` 表达式是一个运算符，不是一个值：
				- ```
				  Add(x) ≜ LAMBDA y : x + y
				  ```
			- 然而，这可以通过函数来轻松实现——在逻辑中，函数是值——我们稍后会看到。
			- 从逻辑的角度来看，运算符是二阶对象，或元语言的对象。TLA+允许将它们作为表示二阶对象的自由变量来处理，这是通过我们将在下一部分学习的 `CONSTANT` 构造以及在证明语言中实现的。因此，虽然上述使用对运算符进行量化的表达式是非法的，但其意图可以在 TLA+ 中表达，我们很快就会看到。
			- 尽管 TLA+ 被认为是无类型的，其语法不仅仅是强制其一阶逻辑的格式正确性（在拒绝形式不正确的表达式，如 `A ∧ ∧ B`）。TLA+ 还在语法上强制运算符的元数，并且使用与定义中不同数量的参数的运算符是一个语法错误。在第三部分和第四部分中，我们将看到一些通过 TLA+ 语法强制执行的更多属性，这本质上是通过类型推断机制完成的。
		- ### 自由变量和未解释变量：CONSTANT
			- 值或运算符可以在没有被定义（使用 `≜`）的情况下声明；相反，它们的含义可以通过使用公理来指定。在逻辑中，那些没有直接以其他符号定义，而是通过给定公理来确定它们如何相互作用的符号，通常被称为未解释符号。在第四部分中，我们将看到这些声明也可以被视为输入或参数，当我们学习模块和模块实例化时。
			- 在 TLA+ 中，自由变量/未解释符号使用关键字 `CONSTANT`（或其同义词 `CONSTANTS`）声明，关于它们的假设——即公理化地断言为真的公式——使用关键字 `ASSUME`（或其同义词 `AXIOM`）引入。例如，如果 `P` 和 `Q` 是一些谓词，我们可以写：
				- ```
				  CONSTANTS A, B
				  ASSUME P(A)
				  ASSUME Q(B)
				  ```
			- 假设也可以命名（`ASSUME A1 ≜ …`），以便在证明中引用它们，其中它们被视为公理。实际上，关键字 `AXIOM` 与 `ASSUME` 同义（唯一的小区别是模型检查器 TLC 检查用 `ASSUME` 声明的假设，但不检查用 `AXIOM` 声明的假设，这就是为什么 `ASSUME` 在 TLA+ 规范中更常见）。
			- 从形式逻辑的角度来看，常量只是自由变量。`P(A)` 和 `Q(B)` 是我们关于 `A` 和 `B` 所知道的全部。如果我们在定理中使用 `A`，那么我们必须证明该定理对任何满足 `P(A)` 的值 `A` 都成立。此外，`Q(A)` 或 `F(A)`（对于任何不仅仅用 `P` 定义的运算符 `F`）的值——即任何表达式的值无法从我们关于 `A` 的公理中确定——是未定义的，正如在关于 `CHOOSE` 的部分所解释的那样。
			- 尽管 `CHOOSE x : P(x)` 和 `CONSTANT x ASSUME P(x)` 在初看似乎非常不同——前者讨论某个使得 `P(x)` 成立的 `x` 的值，而后者讨论任何使得 `P(x)` 成立的 `x`——在两种情况下关于 `x` 的定理证明是相同的：我们必须证明对于所有使得 `P(x)` 成立的 `x` 都适用，因为在任何情况下我们对 `x` 除了 `P(x)` 为真之外都一无所知。然而，这两种构造在使用方式上非常不同。`CHOOSE` 可以用在任何表达式中，并使用涉及到量词或运算符参数的变量的谓词，而 `CONSTANT` 可以被实例化为特定的值（我们将在第四部分学习模块时了解如何做到这一点）。
			- 由于常量不仅可以是值，还可以是运算符，所以从技术上讲，它们是自由的二阶变量。原因是我们可以写出类似下面的内容（我们将在讨论证明时引入 `THEOREM` 构造，但它的含义在这里应该是直观的）：
				- ```
				  CONSTANTS C, D, F(_)
				  THEOREM (C = D) ⇒ (F(C) = F(D))
				  ```
			- 这个定理将 `F` 视为任何运算符，即作为一个自由变量，这相当于我们无法在 TLA+ 中编写的量化的二阶公式：
				- ```
				  ∀C, D, F : (C = D) ⇒ (F(C) = F(D))
				  ```
			- 然而，TLA+ 并没有定义这些二阶对象（即运算符）之间的等式关系。编写：
				- ```
				  CONSTANT F(_), G(_)
				  ASSUME F = G
				  ```
			- 是一个语法错误。必须编写 `ASSUME ∀x : F(x) = G(x)`。
			- 常量是 TLA+ 允许我们陈述二阶命题的一种方式，尽管它是一阶逻辑。我们将在关于证明的部分进一步讨论这个话题。
			- “常量”这个名词仅仅意味着声明的值或运算符不是一个随时间变化的临时性质，当指定一个动态系统时。我们将在第三部分学习时间变量，届时我们将学习如何在 TLA+ 中编写算法，但重要的是要记住，在算法执行过程中，时间变量可能会变化，而常量则不会变化；但是，在不同的执行之间，常量的值是可以改变的。
	- ## **集合**
		- 现在我们已经有了核心逻辑，我们引入这种逻辑的话题宇宙，换句话说，就是我们将要使用的逻辑理论。数据逻辑基于 ZFC 集合论，所以 TLA+ 中的所有值从形式上来说都是集合。即使数字 1 也是一个集合，`TRUE` 是一个集合，函数 `tan` 也是一个集合。但正如我们稍后看到的，这些值如何作为集合进行编码是隐藏的，它们的内部结构对我们来说是不可访问的，它们实际上可能根本就不存在，我们可以安全地将它们当作原始值来对待。
		- 在使用集合论时，我们通常使用一阶逻辑。然而，由于宇宙的值是集合，逻辑的表达能力类似于高阶逻辑。实际上，基于 ZFC 的一阶逻辑被认为是（普通）数学的“标准”形式系统。
		- ### 集合基础
			- 逻辑的符号系统（除一阶逻辑的符号外使用的符号）仅包含成员关系运算符 ∈，这是在所有集合上定义的二元关系（即，对于任何集合 a 和 b，a ∈ b 是有定义的），并且该理论基于具有选择公理的 Zermelo-Fraenkel 集合论的公理。然后，我们使用成员关系定义等式关系 =，即 a = b ≜ ∀x : x ∈ a ≡ x ∈ b（外延公理）；因此，等式也定义在所有集合上（由于等式通常被视为逻辑话语宇宙的原始关系而不是由理论定义，外延公理可以被视为定义等式和成员关系之间的关系）。
			- 量词和 CHOOSE 运算符通常会出现在集合的限定中（例如 ∀x ∈ S: …），在这种情况下，它们的定义如下：
				- (∀x ∈ S: P(x))               ≡ (∀x : x ∈ S ⇒ P(x))
				  (∃x ∈ S: P(x))               ≡ (∃x : x ∈ S ∧ P(x))
				  CHOOSE x ∈ S: P(x) = CHOOSE x : x ∈ S ∧ P(x)
			- 接下来，我们使用集合论的公理指定我们宇宙中存在哪些集合。为了使这更精确（并将所有内容联系起来），回想一下声明某个对象 S — 在我们的案例中，一个集合 — 满足某个属性 P 存在，即 ∃S: P(S)，可以使用选择来完成：P(CHOOSE S: P(S))。以下公理都可以理解为这种形式——即，它们假设 ∃S: P(S) 对于某个谓词 P——只是它们引入了替代写 CHOOSE S: P(S) 的符号。
			- 常量 {} 是空集（空集公理），并且 ∀x : x ∉ {}（这是 ∀x : ¬(x ∈ {}) 的缩写）。即 {} ≜ CHOOSE S : ∀x : x ∉ S，这个集合存在。
			- 如果 a 和 b 是集合，则 S = {a, b} 也是一个集合（配对公理），并且 ∀x : x ∈ {a, b} ≡ x = a ∨ x = b。
			- 如果 S 是一个集合并且 P 是某个谓词，则存在一个集合 T，它包含 S 中满足 P 的所有成员，即 ∀x : x ∈ T ≡ x ∈ S ∧ P(x)（规范化/分离公理）。我们引入了一个方便的语法（称为集合理解），并这样写集合 T：{x ∈ S : P(x)}。例如，{n ∈ Nat : n % 2 = 0} 是自然数中的偶数集合。注意，在集合理解表达式中使用冒号代替了更常见的 |。
			- 如果 S 是一个集合并且 F 是某个表达式，则另一种理解形式，U = {F(x) : x ∈ S}，是通过将 S 的每个成员替换为其在运算符 F 下的像构造的集合（替换公理）；形式上，∀x : x ∈ U ≡ ∃z ∈ S : F(z) = x。例如，{2 * n : n ∈ Nat} 也是自然数中的偶数集合。
			- 如果 S 是一个集合，则 UNION S 是包含 S 的所有成员的成员的集合（并集公理），即 ∀x : x ∈ UNION S ≡ ∃s ∈ S : x ∈ s。例如，UNION {{1, 2}, {2, 3}} = {1, 2, 3}。
			- 如果 S 是一个集合，则 SUBSETS 是 S 的幂集，即 S 的所有子集的集合（幂集公理），或 ∀x : x ∈ SUBSETS ≡ ∀z ∈ x : z ∈ S（注意对于任何集合 S，空集是 SUBSETS 的成员，因为 ∀z ∈ {} : z ∈ S）。例如，SUBSET {1, 2, 3} = {{}, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}}。
			- TLA+ 有常见的集合运算符 ∪（并集）、∩（交集）、⊆（子集或相等）、⊂（严格子集）、\（集合差）等，全部使用上述基本操作简单地定义（例如 a ⊆ b ≜ ∀x : x ∈ a ⇒ x ∈ b，以及 a ∩ b ≜ {x ∈ a : x ∈ b}）。
			- 根据 ZFC 公理定义的上述操作完全确定了我们宇宙中存在的集合。因为 CHOOSE 只选择值，你不能选择罗素悖论“集合”，因为这样的集合不存在，它不能使用任何集合构造操作来构建。因此，CHOOSE x : ∀s : s ∈ x ≡ s ∉ s（这表明 x 是所有不包含自身的集合——一个悖论）的值是未定义的，因为不存在这样的集合 x；CHOOSE 表达式的右侧对 ZFC 中的所有集合都是假的。
			- 让我们看一些使用集合的 TLA+ 定义的例子。这里是一个有用的运算符的例子，它表明一个集合中存在且仅存在一个成员满足某个谓词：
			- ```tla
			  ExistsOne(S, P(_)) ≜ ∃x ∈ S : P(x) ∧ ∀y ∈ S : P(y) ⇒ y = x
			  ```
			  （这是逻辑中表达唯一值的常见模式；如果两个变量指向它必须相等，那么一个值是唯一的）。
			- 请注意，我们可以定义一个无界的运算符，ExistsOne0，
			- ```tla
			  ExistsOne0(P(_)) ≜ ∃x : P(x) ∧ ∀y : P(y) ⇒ y = x
			  ```
			  然后这样定义 ExistsOne：
			- ```tla
			  ExistsOne(S, P(_)) ≜ ExistsOne0(LAMBDA x : x ∈ S ∧ P(x))
			  ```
			  现在让我们定义一些更丰富的数学概念。我们将定义一个有预序的集合（proset）、一个部分有序集（poset）和一个全序集（toset）：
			- ```tla
			  Proset(S, _⪯_) ≜ ∧ ∀a ∈ S : a ⪯ a  							// Reflexivity
			  				 ∧ ∀a, b, c ∈ S : (a ⪯ b ∧ b ⪯ c) ⇒ a ⪯ c  	// Transitivity
			  
			  Poset(S, _⪯_) ≜ ∧ Proset(S, ⪯)
			  				∧ ∀a, b ∈ S : (a ⪯ b ∧ b ⪯ a) ⇒ a = b  		// Antisymmetry
			  
			  Toset(S, _⪯_) ≜ ∧ Poset(S, ⪯)
			  				∧ ∀a, b ∈ S : a ⪯ b ∨ b ⪯ a  				// Totality
			  ```
			  这里是一些重要的代数结构，半群、幺半群和群：
			- ```tla
			  Semigroup(S, _⋅_) ≜ ∧ ∀a, b ∈ S : a ⋅ b ∈ S  // Closure
			  					∧ ∀a, b, c ∈ S : (a ⋅ b) ⋅ c = a ⋅ (b ⋅ c)  // Associativity
			  
			  Monoid(M, _⋅_) ≜ ∧ Semigroup(M, ⋅)
			  				 ∧ ∃id ∈ M : ∀a ∈ M : id ⋅ a = a ∧ a ⋅ id = a  // Identity element
			  
			  Group(G, _⋅_) ≜ ∧ Monoid(G, ⋅)
			  				∧ ∃id ∈ G : ∀a ∈ G : ∧ id ⋅ a = a ∧ a ⋅ id = a 
			                  					 ∧ ∃b ∈ G : a ⋅ b = id ∧ b ⋅ a = id  // Inverse element
			  
			  AbelianGroup(G, _⋅_) ≜ ∧ Group(G, _⋅_)
			  					   ∧ ∀a, b ∈ G : a ⋅ b = b ⋅ a  // Commutativity
			  ```
			- 尽管我可以直接根据 Semigroup 定义 Group，因为我们必须重复身份条件（或使用我们尚未学到的结构），但我想强调群是一个幺半群。身份元素是唯一的，这是我们将来正式陈述和证明的定理。
			- 最终，集合 S 的商集包含其相对于等价关系 ∼ 的等价类（通常写作 S/∼），可以如下定义：
			- ```tla
			  Quotient(S, _∼_) ≜ { x ∈ SUBSET S : ∧ ∀a, b ∈ x : a ∼ b
			    									∧ x ≠ {}
			    									∧ ∀a ∈ S : (∃b ∈ x : a ∼ b) ⇒ a ∈ x}
			  ```
			- 第一个连词表明 x 中的所有成员（作为商集的一个成员）是等价的；第二个连词表明 x 不能是空的；第三个连词表明 x 是最大的，即包含 S 中所有与 x 中成员等价的成员；因此 x 是一个等价类。
			- 对于不习惯编写形式化定义的人——即使是那些习惯的人——可能会忽略写第二个或第三个连词，但 TLA+ 工具可以提供帮助。例如，定义
			- ```tla
			  Quotient({1, 2, 3, 4}, LAMBDA a, b : a % 2 = b % 2)
			  ```
			- 指定了具有相同奇偶性的数字的等价类：
			- ```tla
			  {{1, 3}, {2, 4}}
			  ```
			- TLA+ 工具箱允许你使用模型检查器 TLC 来评估表达式；虽不完全是 REPL，但几乎相同。如果你尝试在没有第三个连词的定义中评估上述表达式，你将会得到
			- ```tla
			  {{2}, {3}, {4}, {1, 3}, {2, 4}}
			  ```
			- 并意识到你的错误。
			- 定义数学概念通常有许多等效的方法。例如，这里是另一种定义 `Quotient` 的方式：
			- ```tla
			  ClassOf(a, S, _∼_) ≜ {b ∈ S : b ∼ a}
			  Quotient(S, _∼_) ≜ {ClassOf(a, S, ∼) : a ∈ S}
			  ```
			- FiniteSets 模块（是 TLA+ 标准模块库的一部分）定义了一些有用的集合操作符，如 `IsFiniteSet(S)`，当 S 是有限的时为真，以及 `Cardinality(S)`，如果 S 是有限的，则为 S 中的元素数量（我们稍后自己定义 `Cardinality`）。
			- `ChooseOne` 是一个有用的操作符，其值仅在给定集合中恰好有一个元素满足谓词时定义：
			- ```tla
			  ChooseOne(S, P(_)) ≜ CHOOSE x ∈ S : P(x) ∧ ∀y ∈ S : P(y) ⇒ y = x
			  ```
			- 另一个有用的操作符是 `AnyOf`，它从集合中随机选择一个元素（如果集合为空则未定义）：
			- ```tla
			  AnyOf(S) ≜ CHOOSE x ∈ S : TRUE
			  ```
			- 说到 `CHOOSE`，因为我们现在知道 TLA+ 中所有值都是集合，并且关系 ∈ 和 = 在所有集合上都有定义，我们应该重新审视“未定义”的定义，因为我们现在可以在表达式中使用一个未定义的值，但仍然可以知道表达式的值。例如，`CHOOSE x : FALSE` 是未定义的，这意味着它是某个无法知晓的值。但由于该值是一个集合，那么例如 `10 ∈ (CHOOSE x : FALSE)` 必须是 TRUE 或 FALSE（因此，类似地，`IF 3 ∈ (CHOOSE x : FALSE) THEN 3 ELSE 5` 必须是 3 或 5）。在这种情况下，我也会说表达式是未定义的，尽管它已知属于某个集合，因为逻辑不允许我们确定其精确值。
			- 我们可以如下使用 `CONSTANT` 和我们刚刚学到的定义：
			- ```tla
			  CONSTANTS S, _⪯_
			  ASSUME Poset(S, ⪯)
			  ```
			- 我们现在可以将 S 视为具有定义在其上的偏序关系的类型参数，类似于某些函数式编程语言中的类型类，或面向对象语言中的接口。
		- ### 一些重要的集合
			- 集合 **BOOLEAN** 定义为 {TRUE, FALSE}，是 TLA+ 的一个重要部分。它的存在至关重要，因为 TLA+ 不区分此集合的元素和逻辑真值——TRUE 和 FALSE 是普通值，即集合，如果 p 是某个谓词（例如 p ≜ a ∈ b），则 p ≡ (p = TRUE) —— 因此，公式（和谓词）是任何其值为 BOOLEAN 的表达式。例如，对于 ∀p ∈ BOOLEAN: p ∨ (5 < 6) 均为真，我们可以写 (3 < 4) = (8 > 2)，使用 = 而不是 ≡，尽管后者是逻辑连接词而前者是集合上的关系，(1 > 0) ∈ BOOLEAN 为真，而不是 (A ⇒ B) ∧ (¬A ⇒ C)，或等价的 (A ∧ B) ∨ (¬A ∧ C)，我们可以写 IF A THEN B ELSE C，尽管如你所记，IF/THEN/ELSE 是根据 CHOOSE 定义的。
			- STRING 是另一个内置集合，它是所有有限字符字符串的集合。字符串是字符序列（我们将在下一部分讨论序列），字符是具有不透明编码的原始值；TLA+ 没有字符字面量的语法。
			- 模块 Naturals、Integers 和 Reals 分别定义了集合 Nat (N)、Int (Z) 和 Real (R)，其中 Nat ⊂ Int ⊂ Real，以及熟悉的算术运算符（自然数和整数定义了加法、减法、乘法、整除 ÷ 和模运算 %；除法仅为实数定义），序关系（≤）等。从模块中导入公共定义是通过 EXTENDS 语句完成的，如 EXTENDS Naturals。除非你导入定义了它们的模块，否则你不能在 TLA+ 规范中使用算术运算符（数字字面量是内置的）。TLA+ 目前没有复数或矩阵的特殊语法，也不包括定义有理数 (Q) 的标准模块。
			- 特殊语法 a..b 定义了集合 {n ∈ Int : n ≥ a ∧ n ≤ b}，因此 −1..1 = {−1, 0, 1}，2..5 = {2, 3, 4, 5} 而 5..2 = {}。
			- 实数的除法（在 Reals 模块中定义）可以这样定义：
			- a / b ≜ CHOOSE c ∈ Real : a = b * c
			- 这个定义立即告诉我们，通过讨论 CHOOSE 操作符的含义，1 / 0 是未定义的，这是非常精确的解释。
			- 有了数字、算术操作和数字的序关系，我们可以开始做一些更具体的数学。我们将从一个简单的定义开始：一个表示一个数是否为素数的谓词操作符 Prime（也可以有其他定义）：
			- Divides(p, n) ≜ ∃q ∈ Int: p * q = n
			  Prime(n) ≜ n > 1 ∧ ∀p ∈ Nat: Divides(p, n) ⇒ p = n ∨ p = 1
			- 现在让我们定义 GCD 操作符，两个自然数的最大公约数：
			- DivisorsOf(n) ≜ {p ∈ Int : Divides(p, n)}
			  SetMax(S) ≜ CHOOSE x ∈ S : ∀y ∈ S : x ≥ y
			  GCD(m, n) ≜ SetMax(DivisorsOf(m) ∩ DivisorsOf(n))
			- 注意 GCD 定义的直接性：首先我们定义了什么是除数；然后定义了一个数的除数。两个数的公共除数就是这两个数除数的交集，GCD 是其中最大的一个。
			- 我们可以使用我们之前看到的集合和一些定义来陈述几个有趣的定理：
			- ```
			  THEOREM AbelianGroup(Int, +)
			  
			  THEOREM ∀n ∈ Nat \ {0}: LET a ∼ b ≜ a % n = b % n 							Equality modulo n
			  						    a ⊕ b ≜ ClassOf(AnyOf(a) + AnyOf(b), Int, ∼) 	Sum on equiv. classes
			                          IN  AbelianGroup(Quotient(Int,~),⊕)
			  ```
			- 重要的是要指出，Nat 是所有自然数的集合，Int 是所有整数的集合，而 Real 是实际的实数集合——它们数量无法计数。如果我们想要使用，比如，32位整数或64位浮点数，我们需要定义它们及其算术运算。你可能会想，考虑到程序只能表示其中一小部分，这么多实数有什么用。答案是，TLA+ 不是一种编程语言，而是一种规格说明语言，它对于指定和推理不仅仅是你程序的实际变量非常有用。例如，如果你正在指定一个数值算法，如果能够精确表达它试图近似的结果，分析其误差就更容易了。或者，如果你正在构建一个网络物理系统——一个与现实世界中的对象交互的离散系统；想想无人机、传感器或机器人——你可能也想模拟系统的环境，使用熟悉的物理方程描述它作为一个连续系统会更容易（我们将在第四部分讨论网络物理系统）。
		- ### 集合等价性
			- 在集合论中，所有的值都被编码为某种集合（因此数字1以某种方式被编码为一个集合），正如我们所学到的，等价性是定义在所有集合上的一种关系，可以被定义为：
			- a = b ≜ ∀x : x ∈ a ≡ x ∈ b
			- （除了，正如我们所见，布尔值在TLA+中也是集合而非逻辑本身的特殊常量，因此 ≡ 是基于 = 定义的，而 = 必须是原始的）。
			- 当一个集合被定义时，这种编码至少在概念上是定义的一部分，因此该集合的等价性也被定义。然而，比较不同集合中的值是另一回事。TLA+允许我们在模块内隐藏编码，使其细节不逸出模块边界，并向外部模块呈现为原语或未解释的（我们将在第四部分讨论模块），因此 1 ∈ 2 或 1 = "hi" 的值是未定义的（即无法确定的）。由于整数和字符串是分开定义的，它们彼此之间不了解对方的编码；我们简单地不知道 1 和 "hi" 是否有相同的编码，因此是否是同一个集合并且相等，或者不是（我们确实知道整数 1 和实数 1 是相等的，因为实数被定义为整数的超集）。
			- 因为等价性（和成员关系）在所有集合上被定义为具有布尔值，我们确实知道 1 = "hi" 必须是某种布尔值，即要么是 TRUE 要么是 FALSE，但我们无法确定哪一个。在类型化的形式系统中，表达式 1 = "hi" 根本就是非法的（格式不正确）；在动态类型的编程语言中，它评估为假。但在TLA+中，它根本没有意义——我们不能给它赋予任何意义，即一个值——就像英语表达式“星期四是紫色”，这在语法上是合法的，或者说格式正确，但没有公认的含义。如果你想回顾这种选择的权衡，我将引用我上面链接的两篇论文。
			- 因此，我们不知道集合 {1, "hi"} 包含一个元素还是两个元素，因为我们无法确定 1 是否等于 "hi"，也不知道 "hi" 是如何编码的（TLC 完全禁止这样的集合，因为其元素无法比较）。那么，如果我们想要一个包含值 0、1 和 UNKNOWN 的集合，我们该怎么办呢？我们使用 CHOOSE 来定义 UNKNOWN，如下所示：
			  UNKNOWN ≜ CHOOSE x : x ∉ {0, 1}
			  然后我们可以写出集合 {0, 1, UNKNOWN}，现在已知它包含三个元素。
			- 因此，虽然 TLA+ 是无类型的，但它的工作方式与通常的“动态类型”的无类型编程语言不同。
		- ### 函数
			- 我们在数学和编程中处理的大多数有趣对象通常不被视为集合。TLA+ 允许我们清晰地表达标准的数学和编程对象，其中函数作为主要的构建块。
			- 通常，函数被定义为单值关系，其中关系是一组对 — 换句话说，函数通过其图来定义 — 但在 TLA+ 中，函数不是定义为一组对，而是作为原语（这意味着，像数字一样，它们作为集合的编码是未知的或不透明的）。事实上，在 TLA+ 中，实际上是对是函数，因为它们是序列的特殊情况，而序列又是函数的特殊情况，正如我们将看到的。无论如何，在 TLA+ 中，函数不是计算；它们没有动态行为和计算复杂性。它们只是算法状态空间中的值。程序员可能最好将它们视为关联数组，尽管可能是无限大的（甚至是不可数的大）。
			- 如果 A 和 B 是集合，[A → B] 是从 A 到 B 的所有函数的集合。函数应用使用方括号表示 (f[x])，以在语法上将其与运算符“应用”（实际上是替代）区分开来。与运算符不同，其参数可以是宇宙中的任何值甚至是其他运算符，每个函数都有一个域 — 一个集合 — 可以使用 DOMAIN 运算符获得，如下所示 ∀f∈[A→B]: DOMAIN f = A。因为函数有一个集合域，我们不能有一个参数可以是任何集合甚至任何函数的函数（就像我们可以用运算符一样），因为那将使函数的域“太大而不能是一个集合”，即一个适当的类，这在 ZFC 中不存在。
			- 函数是我们逻辑中的（一阶）对象 — 它们只是（不透明的）集合本身 — 而运算符不是（它们是二阶对象，或者是元语言中的对象）。因此，我们可以像对待任何其他值一样对函数进行量化，如在 ∀f∈[A→B]: … 中。因为函数作为集合的编码是不透明的，像 3∈f 这样的声明，对于某个函数 f，是未定义的和无意义的。
			- 函数的像可以定义为：
			- Image(f) ≜ {f[x] : x ∈ DOMAIN f}
			- 函数的等价是外延的，意味着对于两个函数 f 和 g，
			- (f = g) ≡ (DOMAIN f = DOMAIN g ∧ ∀x ∈ DOMAIN f : f[x] = g[x])
			- 我们可以定义一个在自然数上的特定函数 double 如下，
			- double ≜ CHOOSE f ∈ [Nat → Nat] : ∀n ∈ Nat : f[n] = 2*n
			- 但这样做会非常繁琐，因此 TLA+ 允许我们这样定义它：
			- double ≜ [n ∈ Nat ↦ 2*n]
			- 或者这样，
			- double[n ∈ Nat] ≜ 2*n
			- 后一种形式是语法糖，
			- double ≜ CHOOSE f : f = [n ∈ Nat ↦ 2*n]
			- 因此，以这种形式定义的函数可以是递归的：
			  fact[n ∈ Nat] ≜ IF n ≤ 1 THEN 1 ELSE n * fact[n - 1]
			- 这只是下面表达式的简写，
			  fact ≜ CHOOSE f : f = [n ∈ Nat ↦ IF n ≤ 1 THEN 1 ELSE n * f[n - 1]]
			- 这将 fact 定义为一个不动点（或固定点）。为了更清楚地看到这一点，我们可以定义：
			- Fixpoint(F(_)) ≜ CHOOSE x : x = F(x)
			- 然后：
			  fact ≜ Fixpoint(LAMBDA f : [n ∈ Nat ↦ IF n ≤ 1 THEN 1 ELSE n * f[n - 1]])
			- 请注意，递归函数因为实际上被指定为不动点，如果不动点不存在，可能会变成未定义的，如以下情况：
			- f[n ∈ Nat] ≜ 1 + f[n]
			- 因此，在证明中使用递归函数定义时，您可能需要证明它们确实定义了实际的函数，通过显示它们确实在其域的每个值上匹配一个值（或用计算机科学的话来说，它们是完全的）。
			- 函数可以在任何集合（包括函数的集合）上定义，并且可以返回任何值，包括其他函数。因此，我们可以定义一个“高阶”函数：
			- ```plaintext
			  add[x ∈ Nat] ≜ [y ∈ Nat ↦ y + x]
			  ```
			- 然后定义：
			- ```plaintext
			  inc ≜ add[1]
			  ```
			- 然而，在形式上，与类型化形式主义不同，像 `add` 这样的函数在 TLA+ 中并不真正是高阶的，因为所有的函数——实际上所有的值——都具有相同的类型；它们都是值集合的宇宙中的值。
			- 现在我们可以定义一些函数的常见重要属性：单射（一对一映射）、满射（到达映射）和双射：
			- ```plaintext
			  Injection(f)     ≜ ∀x, y ∈ DOMAIN f : x ≠ y ⇒ f[x] ≠ f[y]
			  Surjection(f, S) ≜ ∀y ∈ S : ∃x ∈ DOMAIN f : f[x] = y
			  Bijection(f, S)  ≜ Surjection(f, S) ∧ Injection(f)
			  ```
			- 其中变量 `S` 表示函数的陪域。注意我们也可以将 `Injection` 定义为：
			- ```plaintext
			  ∀y ∈ Image(f) : ExistsOne(DOMAIN f, LAMBDA x : f[x] = y)
			  ```
			- 现在让我们定义一个函数复合操作符（我将使用 `∙` 操作符，因为 `∘`，通常用于函数复合的符号，在 TLA+ 中通常用于序列连接）：
			- ```plaintext
			  g ∙ f ≜ [x ∈ DOMAIN f ↦ g[f[x]]]
			  ```
			- 注意 `g ∙ f` 只有在 `f` 和 `g` 可组合时才定义，这意味着 `Image(f) ⊆ DOMAIN g` —— 记住，至少在普通数学中，没有所谓的部分函数，至少不是与编程中相同的意义。如果我们想要像编程中的部分函数那样工作的函数复合，我们可以定义：
			- ```plaintext
			  g ⋆ f ≜ LET Preimage(h, S) ≜ {x ∈ DOMAIN h : h[x] ∈ S} 
			          IN [(x ∈ DOMAIN f ∩ Preimage(g, Image(f))) ↦ g[f[x]]]
			  ```
			- 与 `g ∙ f` 不同，`g ⋆ f` 总是一个函数，但它不一定是在 `DOMAIN f` 上的函数，而是可能只在其子集上，如果 `Image(f) ∩ DOMAIN g = {}`，它甚至可能是空函数（在空集上的函数，任何参数都未定义的函数）。
			- 以下运算符定义了任意集合上的恒等函数：
			- ```
			  Identity(S) ≜ [x ∈ S ↦ x]
			  ```
			- 以下是关于`Identity`的一个定理：
			- ```
			  ∀S: ∀x ∈ S: Identity(S)[x] = x
			  ```
			- 我们还定义了一个`Inverse`运算符，用于任何可逆函数的逆（定义如下：对于函数图像中的任何`y`，选择一个映射到`y`的定义域中的`x`，前提是`x`是唯一映射到`y`的点）：
			- ```
			  Inverse(f) ≜ [y ∈ Image(f) ↦ ChooseOne(DOMAINf, LAMBDA x: f[x] = y)]
			  ```
			- 如果一个函数的值域中的每个元素在其定义域中有且只有一个对应元素映射到它，即它是一个双射，则该函数是可逆的。我们希望将这作为一个关于函数的一般定理，但这里有一个问题：所有函数的集合不是一个集合（而是一个正确的类），所以我们不能写`∀f ∈ Function: ...`（与类型化的函数式语言中的类型 forall a b. a → b 表示所有函数不同）。然而，我们可以定义谓词`Fn`，它的定义看似愚蠢，当且仅当其参数是任何函数时为真：
			- ```
			  Fn(f) ≜ f = [x ∈ DOMAINf ↦ f[x]]
			  ```
			- 接下来是一个定理：
			- ```
			  ∀S, f: Fn(f) ∧ Bijection(f, S) ⇒ ∧ Inverse(f) ∙ f = Identity(DOMAINf) 
			  								 ∧ f ∙ Inverse(f) = Identity(S)
			  ```
			- 如下：
			- ```
			  ∀f: Fn(f) ∧ Injection(f) ⇒ ∧ Inverse(f) ∙ f = Identity(DOMAINf) 
			  						   ∧ f ∙ Inverse(f) = Identity(Image(f))
			  ```
			- 我们可以通过各种方式操纵函数。例如，如果`inc`是上面定义的将每个自然数增加一的函数，我们当然可以定义以下内容：
			- ```
			  g ≜ [x ∈ Nat ↦ IF x ≥ 1 ∧ x ≤ 2 THEN inc[x] * 10 ELSE inc[x]]
			  ```
			- 但是`EXCEPT`构造使得“更改”特定函数值变得更容易：
			- ```
			  g ≜ [inc EXCEPT ![1] = inc[1] * 10, ![2] = inc[2] * 10]
			  ```
			- 上述也可以这样写：
			- ```
			  g ≜ [inc EXCEPT ![1] = @ * 10, ![2] = @ * 10]
			  ```
			- 其中`@`指的是该点原始函数的值。
			- `EXCEPT` 表达式还支持函数可以“嵌套”的情况（即，一个函数返回另一个函数，或多维数组）。因此，如果我们想表达增加二维数组中（1,2）坐标的值，而不是写：
			- ```
			  [f EXCEPT ![1] = [@ EXCEPT [2] = @ + 1]]
			  ```
			- 我们可以写成：
			- ```
			  [f EXCEPT ![1][2] = @ + 1]
			  ```
			- 我们还有语法糖来定义和应用具有多个参数的函数。我们将在学习了元组之后讨论这个问题。
			- 定义不可计算的函数和定义可计算的函数一样容易。这里是一个不可计算函数的例子：
			- ```
			  dirichlet[x ∈ Real] ≜
			  	LET IsRational(z) ≜ ∃p ∈ Int, q ∈ Nat \ {0} : z = p / q
			      IN IF IsRational(x) THEN 1 ELSE 0
			  ```
			- 顺便说一下，尽管初看起来非常简单自然，这个函数也是如此：
			- ```
			  step[x ∈ Real] ≜ IF x < 0 THEN 0 ELSE 1
			  ```
			- 这些例子展示了如何定义涉及条件逻辑和存在性量词的函数，以及如何用`EXCEPT`表达式修改函数的特定值或行为。
			- 现在让我们使用函数和我们之前见过的一些集合来正式定义一些更重要的数学概念：
			- ```
			  RealFunction ≜ UNION { [S → Real] : S ∈ SUBSET Real }
			  ```
			- 绝对值函数定义为：
			- ```
			  AbsoluteValue(a) ≜ IF a ≥ 0 THEN a ELSE −a
			  ```
			- 开球（在实数线上的开区间）定义为：
			- ```
			  OpenBall(a, e) ≜ { x ∈ Real : AbsoluteValue(x − a) < e }
			  ```
			- 正实数集定义为：
			- ```
			  PosReal ≜ { x ∈ Real : x > 0 }
			  ```
			- 极限的定义（使用著名的（ϵ, δ）定义）：
			- ```
			  Limit(f, a) ≜ CHOOSE l ∈ Real : 
			  				∀e ∈ PosReal : ∃d ∈ PosReal :
			                  	∀x ∈ OpenBall(a, d) \ {a} : f[x] ∈ OpenBall(l, e)
			  ```
			- 导数的定义为：
			- ```
			  Derivative(f, a) ≜ LET e ≜ CHOOSE e ∈ PosReal : OpenBall(a, e) ⊆ DOMAIN f 
			  				   IN Limit([x ∈ OpenBall(a, e) \ {a} ↦ (f[x] − f[a]) / (x − a)], a)
			  ```
			- 虽然我们可以定义任何可计算的函数（甚至许多不可计算的函数），但这些函数并不是我们在 TLA+ 中描述计算的方式。与基于函数式编程的规范语言不同，TLA+ 中的计算不是函数而是动态系统（如常微分方程）。相反，我们将函数用作数据结构（关联数组）或者像操作符一样，作为我们计算的基本操作。例如，当我们编写高层规范时，如果我们不希望模拟比如阶乘子程序的动态行为，而是将其视为原始操作，我们会将其指定为一个函数。
		- ### 序列和元组
			- 序列是有限或无限的有序值列表。在TLA+中，序列被定义为在自然数（去除0）的某个前缀上的函数，因此使用了数学中常见的从1开始的索引，而这与大多数编程语言中常用的从0开始的索引不同。
			  所有偶数的升序序列可以表示为 [n ∈ 自然数 \ {0} ↦ 2 * (n - 1)]，而2到200之间所有偶数的序列可以表示为 [n ∈ 1..100 ↦ 2 * n]。
			- 序列模块包含了许多用于处理序列的有用定义。Seq(S) 是集合S上所有有限序列的集合（无限序列的集合就是 [自然数 \ {0} → S]），定义如下：
			- Seq(S) ≜ UNION { [1..n → S] : n ∈ 自然数 }
			  Len(s) 操作符是序列的长度（可以定义为 CHOOSE n ∈ 自然数 : DOMAIN s = 1..n）；∘ 操作符用于连接两个序列，Append(seq, x) 操作符将值x追加到序列seq的末尾，Head(seq) 操作符是序列的第一个元素（seq[1]），而 Tail(seq) 是尾部（[i ∈ 1..Len(seq) - 1 ↦ seq[i + 1]]）。SubSeq(seq, i, j) 是序列seq中从i到j（包括i和j）的子序列，而 SelectSeq(seq, P(_)) 是过滤后只包含满足P(x)为真的元素x的序列。
			- 由于字符串只是字符的序列，序列模块的∘操作符也用于连接字符串，SubSeq用于选择子字符串等。
			- 在序列上定义熟悉的函数式编程中的 map 操作很简单：
			- ```
			  Map(F(_), seq) ≜ [i ∈ DOMAIN seq ↦ F(seq[i])]
			  ```
			- flatmap 需要更多的工作，以及使用递归操作符（由于 TLA+ 不允许带有操作符参数的递归操作符，因此需要内部辅助操作符）：
			- ```
			  FlatMap(F(_), seq) ≜ LET RECURSIVE Helper(_) 
			  						Helper(s) ≜ IF Len(s) = 0 THEN ⟨⟩ 
			                          		                  ELSE F(Head(s)) ∘ Helper(Tail(s)) 
			                       IN Helper(seq)
			  ```
			- TLA+ 对有限序列字面量有特殊的语法，也称为元组（或者如果你愿意，可以称之为列表）。元组 `⟨10, ‘‘hi", [x ∈ N ↦ x + 1]⟩` 仅仅是语法糖：
			- ```
			  [i ∈ 1..3 ↦ CASE i = 1 → 10 □ i = 2 → ‘‘hi" □ i = 3 → [x ∈ N ↦ x + 1]]
			  ```
			- 如果 `A` 和 `B` 是集合，那么 `A×B` 是它们的笛卡尔积，`{⟨a, b⟩ : a ∈ A, b ∈ B}`。类似地，`A×B×C = {⟨a, b, c⟩ : a ∈ A, b ∈ B, c ∈ C}` 等等。在 TLA+ 中，笛卡尔积不是关联的，所以 `A×B×C ≠ (A×B)×C ≠ A×(B×C)`，因为 `⟨a, b, c⟩ ≠ ⟨⟨a, b⟩, c⟩ ≠ ⟨a, ⟨b, c⟩⟩`（因此 `×` 不是一个普通的二元中缀运算符——尽管它的行为几乎如此——而是一个特殊的构造）。
			- 为了方便起见，元组可以用作量化变量：可以将 
			  ∃pair∈A×B: pair[1] > pair[2] 
			  写成 
			  ∃⟨a, b⟩∈A×B: a > b。
			- 采用多个参数的函数是以元组形式定义的语法糖。我们可以写：
			- ```
			  [x ∈ Nat, y ∈ STRING ↦ x + Len(y)]
			  ```
			- 这只是以下语法糖的表达形式：
			- ```
			  [⟨x, y⟩ ∈ Nat × STRING ↦ x + Len(y)]
			  ```
			- 同样，我们可以将同一个函数定义为：
			- ```
			  foo[x ∈ Nat, y ∈ STRING] ≜ x + Len(y)
			  ```
			- 我们可以使用表达式 `foo[3, ‘‘hi"]` 来应用这样的函数，这只是 `f[⟨3, ‘‘hi"⟩]` 的语法糖。
		- ### 记录（Records）
			- 记录：
			- ```
			  [a ↦ 10, b ↦ 20, c ↦ 30]
			  ```
			- 是以下函数的语法糖：
			- ```
			  [f ∈ {"a", "b", "c"} ↦ CASE f = "a" → 10 □ f = "b" → 20 □ f = "c" → 30]
			  ```
			- 并且 `r.a` 是 `r["a"]` 的语法糖。
			- `EXCEPT` 还有特殊的语法用于记录，所以一个与 `r` 相等但其“字段” `b` 为 200 的记录，可以用
			- ```
			  [r EXCEPT !.b = 200]
			  ```
			- （或用
			- ```
			  [r EXCEPT !.b = @*10]
			  ```
			- ）创建。嵌套结构也可以工作（例如，
			- ```
			  [r EXCEPT !.a.k = @+1]
			  ```
			- ）。最后，我们有特殊的语法用于记录的集合：
			- ```
			  [name: STRING, id: Nat]
			  ```
			- 是所有具有字段 `name` 和 `id`，其中 `name` 字段是一个字符串，而 `id` 是一个自然数的记录的集合。
		- ### 运算符与值
			- 你应该将数学函数表示为 TLA+ 函数还是运算符？类似地，你应该将关系表示为一组对还是二元运算符？这完全取决于你。将它们表示为理论中的对象，即作为函数或集合，“具体化”它们，允许选择它们或对它们进行量化，这在你的规范中可能是必要的，也可能不是必要的。使用运算符在语法上可能更方便（例如，`x ⪯ y` 看起来比 `⟨x, y⟩ ∈ OrderRel` 更好看）。有时候，选择由你想要用来验证规范的工具的能力决定。例如，机械证明系统 TLAPS 目前不支持递归运算符定义，但它支持递归函数（只是为 `CHOOSE` 的语法糖）。此外，运算符可以表达函数简单无法表达的事物。例如，序列长度运算符或集合基数运算符（我们稍后将看到）不能被定义为函数，因为它们在集合论中不是函数，它们的域不是一个集合，而是“太多”集合（即一个集合，一个在 ZFC 中不能构建为一个集合的类）。
	- ## **综合起来**
		- 我们学到的逻辑使我们能够定义计算机程序操作的数据的任何信息。
		- ### 更复杂的定义
			- 现在让我们使用我们所见过的一切来定义 `Cardinality(S)` 运算符，该运算符是有限集合 `S` 中元素的数量（该运算符由标准模块 FiniteSets 提供）。
			- 我们可以使用计算机科学的定义，基于这样的观察：有限集合的基数是去掉一个任意元素后集合的基数加一：
			- ```
			  RECURSIVE Cardinality(_)
			  Cardinality(s) ≜ IF s = {} THEN 0 
			  						   ELSE LET x ≜ CHOOSE x ∈ s : TRUE
			                             		IN 1 + Cardinality(s \ {x})
			  ```
			- 我们也可以选择更“数学化”的定义。我们将通过找到一个从自然数范围到集合的双射来定义基数。
			- ```
			  Cardinality(s) ≜ CHOOSE n ∈ Nat : ∃f ∈ [1..n → s] : Bijection(f, s)
			  ```
			- 我们可以通过使用以下数学定义来展示一些其他的 TLA+ 特性，该定义找到最大的自然数 `n`，使得从 `1..n` 到 `s` 有一个注入（一对一映射）：
			- ```
			  Cardinality(s) ≜ 
			  	LET TheLargestSuch(S, _≻_, P(_)) ≜
			      		CHOOSE x ∈ S : P(x) ∧ ∀y ∈ S : y ≻ x ⇒ ¬P(y) 
			      IN TheLargestSuch(Nat, >, LAMBDA n : ∃f ∈ [1..n → s] : Injection(f))
			  ```
		- ### 描述数据的属性
			- 我们用所有这些知识做什么呢？我们使用TLA+值来定义程序在执行的任何步骤中的数据，以及我们的计算在一步中可以执行的原始操作。数据结构可以使用我们学到的对象轻松定义：数组和列表可以被建模为序列；结构可以被建模为记录；映射可以被建模为函数，集合则可以，嗯，作为集合。
			- 那么像堆和栈这样的东西呢？进程或线程又如何呢？在TLA+中，你可以选择抽象级别。如果你愿意，你可以在较低的层面上模拟内存，作为包含字节的数组（比如，作为0到255之间的自然数），并编写像malloc和free这样的内存分配和释放操作的定义，以及处理编码和解码构造（如字符串、数组、浮点数等）到字节的定义。然而，在大多数情况下，你更可能选择纯粹抽象地模拟这些构造，而不用担心它们的内存布局，或者你可以选择找到某种中间地带，其中内存是在对象中分配和释放的，但不用担心较低层次的表示，而是模拟处理共享指针的有趣技术，如分离逻辑。至于进程，我们将在第三部分看到它们是如何被模拟的。
			- 我们在指定实际软件系统时看到的非可计算函数或运算符（如 `Inverse` 或 `dirichlet`）有什么用呢？就此而言，即使定义是可计算的，它也可能不暗示一种可行（易处理）的计算方式，这同样糟糕。正如我们将在接下来的内容中看到的，这样的定义可以是实际可执行算法的便捷抽象表示。它们指定了我们的程序或其某小部分的‘什么’而非‘如何’，然后我们可以选择定义‘如何’并验证它是否符合‘什么’，或者选择就此打住，不担心实现。
			- 例如，在指定依赖于排序函数的一些复杂算法时，我们可能知道我们已经有了一个高效的排序子程序库，我们对其实现的细节不感兴趣。因此，我们可以选择仅定义其行为，而不是将排序子程序指定为算法或以模仿高效实现的方式定义它：
			- ```
			  Permutations(seq) ≜ LET N ≜ Len(seq) 
			  						PermsOfNums ≜ { f ∈ [1..N → 1..N] : Injection(f) } 
			                      IN { seq ∙ perm : perm ∈ PermsOfNums }
			                      
			  Ordered(seq, _⪯_) ≜ ∀ i, j ∈ 1..Len(seq) : i < j ⇒ seq[i] ⪯ seq[j]
			  
			  Sort(seq, _⪯_) ≜ CHOOSE out ∈ Permutations(seq) : Ordered(out, ⪯)
			  ```
		- ### 数据细化和归纳数据类型
			- 为了使事情更具体化，让我们考虑链接列表的一个规格说明。假设我们决定将列表模型化为链接节点，但我们选择不涉及实际的指针运算，因此我们不会直接模型化内存。
			- 虽然在TLA+中不是必需的，我们可以从指定我们的链接列表节点的“类型”开始，这里的类型我指的是节点的一般结构（不涉及内存布局）。我们列表的元素可以是集合 S 中的任何成员。
			- 我们可能会被诱惑去定义列表的“类型”——即所有列表的集合，像这样：
			- ```
			  CONSTANTS
			  EMPTY ≜ ⟨⟩ // 或者任何可以与节点记录比较的值
			  RECURSIVE List
			  List ≜ {EMPTY} ∪ [value: S, next: List]
			  ```
			- 然而，与任何递归（即自我引用）定义一样，存在一些微妙之处，因为递归意味着一个固定点方程，但许多递归有多个解决方案，而TLA+并不承诺特定的一个。上面定义的最后两行可以对应以下一行：
			- ```
			  List ≜ CHOOSE List: List = {EMPTY} ∪ [value: S, next: List]
			  ```
			- 由于 CHOOSE 选择任何满足方程的集合，上面的行可能代表所有有限链接列表的集合，或者所有有限和无限链接列表的集合，这是另一个解决方案。如果我们想要具体一点，例如，只表示有限列表的集合，我们可以改为定义：
			- ```
			  List ≜ LET ListUpToLength[n ∈ Nat] ≜
			  			IF n = 0 THEN {EMPTY}
			  					 ELSE [value: S, next: ListUpToLength[n−1]] ∪ ListUpToLength[n−1]
			  	   IN UNION {ListUpToLength[n] : n ∈ Nat}
			  ```
			- 实际上，我们可以将这个想法推广：
			- ```
			  InductiveDataType(base, Cons(_)) ≜
			  	LET upToSize[n ∈ Nat] ≜
			    		IF n = 0 THEN base
			    				 ELSE Cons(upToSize[n−1]) ∪ upToSize[n−1]
			  	IN UNION {upToSize[n] : n ∈ Nat}
			  ```
			- 然后：
			- ```
			  List ≜ InductiveDataType({EMPTY}, 
			  						 LAMBDA List: [value: S, next: List])
			  ```
			- 注意，LAMBDA 中的 List 不是我们正在定义的集合，即左侧的 List，而仅仅是 LAMBDA 参数的名称。
-