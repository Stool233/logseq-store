- **Tags**: [[Code Intelligence]] [[Code Navigation]] [[tree-sitter]]
-
- 相关的文章、论文
	- https://github.blog/2021-12-09-introducing-stack-graphs/
		- 一篇介绍
	- https://dcreager.net/talks/stack-graphs/
		- 会议分享video
	- https://media.dcreager.net/dcreager-2022-ucsc-lsd-slides.pdf
		- 会议分享video相关的PPT
	- https://github.com/github/stack-graphs
		- 相关源码
	- https://news.ycombinator.com/item?id=29500602
		- 作者在黑客论坛上的讨论
	- https://arxiv.org/pdf/2211.01224.pdf
		- 相关发表的论文
	- https://github.github.io/stack-graph-docs/
		- 内部文档
-
- Stack graphs（Name resolution at scale）
	- 来源：
		- https://arxiv.org/pdf/2211.01224.pdf
	- abstact
		- 我们提出了堆栈图，这是Visser等人的范围图框架的扩展。堆栈图支持GitHub的精确代码导航，允许用户在存储库内部和跨存储库导航名称绑定引用。与作用域图一样，堆栈图在图结构中编码有关程序的名称绑定信息，其中路径表示有效的名称绑定。然后通过简单的寻路搜索实现对其定义的引用解析。
		- GitHub拥有数百万个存储库，包含总代码数pb，以数百种不同的编程语言实现，每分钟接收数千次推送。
			- 为了支持这种规模，我们确保图的构造和寻路判断是文件增量的:
				- 对于每个源文件，我们创建一个孤立的子图，而不需要了解程序中的任何其他文件，也不需要看到程序中的任何其他文件。
				- 这让我们消除了重新分析我们已经看到的文件版本的存储和计算成本。
				- 由于大多数提交只更改存储库中文件的一小部分，因此这大大降低了为大型、频繁更改的存储库建立索引的操作成本。
		- 为了处理面向类型的名称查找(需要“暂停”当前查找以解析另一个名称)，我们的名称解析算法维护当前暂停(但仍然挂起)查找的堆栈。
		- 堆栈图可以通过对程序源代码的纯语法分析来构建，使用一种新的声明式图构建语言。
			- 这意味着我们可以为每个存储库提取名称绑定信息，而无需任何包配置，也无需调用任意的、不受信任的、特定于包的构建过程。
	- Introduction
		- 代码编辑器长期以来一直提供诸如代码导航之类的生产力特性，它允许用户查看和导航代码中的结构关系，特别是代码中的名称所引用的实体。
		- 这些特性在像GitHub这样的软件锻造平台上同样有用。
		- 然而，大型软件伪造必须支持一个完全不同的规模，沿着一些轴:
			- 存储代码的总量;
			- 一段时间内收到的更改数量;
			- 需要查询历史版本的代码;同时进行查询的用户数量;以及支持的编程语言的数量。