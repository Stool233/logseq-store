- **Tags**: [[Code Intelligence]] [[Code Navigation]] [[tree-sitter]]
-
- 相关的文章、论文
	- https://github.blog/2021-12-09-introducing-stack-graphs/
		- 一篇介绍
	- https://dcreager.net/talks/stack-graphs/
		- 会议分享video
	- https://media.dcreager.net/dcreager-2022-ucsc-lsd-slides.pdf
		- 会议分享video相关的PPT
	- https://github.com/github/stack-graphs
		- 相关源码
	- https://news.ycombinator.com/item?id=29500602
		- 作者在黑客论坛上的讨论
	- https://arxiv.org/pdf/2211.01224.pdf
		- 相关发表的论文
	- https://github.github.io/stack-graph-docs/
		- 内部文档
-
- Stack graphs（Name resolution at scale）
	- 来源：
		- https://arxiv.org/pdf/2211.01224.pdf
	- abstact
		- 我们提出了堆栈图，这是Visser等人的范围图框架的扩展。堆栈图支持GitHub的精确代码导航，允许用户在存储库内部和跨存储库导航名称绑定引用。与作用域图一样，堆栈图在图结构中编码有关程序的名称绑定信息，其中路径表示有效的名称绑定。然后通过简单的寻路搜索实现对其定义的引用解析。
		- GitHub拥有数百万个存储库，包含总代码数pb，以数百种不同的编程语言实现，每分钟接收数千次推送。
			- 为了支持这种规模，我们确保图的构造和寻路判断是文件增量的:
				- 对于每个源文件，我们创建一个孤立的子图，而不需要了解程序中的任何其他文件，也不需要看到程序中的任何其他文件。
				- 这让我们消除了重新分析我们已经看到的文件版本的存储和计算成本。
				- 由于大多数提交只更改存储库中文件的一小部分，因此这大大降低了为大型、频繁更改的存储库建立索引的操作成本。
		- 为了处理面向类型的名称查找(需要“暂停”当前查找以解析另一个名称)，我们的名称解析算法维护当前暂停(但仍然挂起)查找的堆栈。
		- 堆栈图可以通过对程序源代码的纯语法分析来构建，使用一种新的声明式图构建语言。
			- 这意味着我们可以为每个存储库提取名称绑定信息，而无需任何包配置，也无需调用任意的、不受信任的、特定于包的构建过程。
	- Introduction
		- 代码编辑器长期以来一直提供诸如代码导航之类的生产力特性，它允许用户查看和导航代码中的结构关系，特别是代码中的名称所引用的实体。
		- 这些特性在像GitHub这样的软件工厂平台上同样有用。
		- 然而，大型软件工厂必须在多个方向上支持完全不同数量级的规模：
			- 存储代码的总量;
			- 一段时间内收到的更改数量;
			- 需要查询历史版本的代码;
			- 同时进行查询的用户数量;
			- 以及支持的编程语言的数量。
		- 我们已经开发了堆栈图来解决这些限制。
			- 堆栈图建立在Visser等人的作用域图框架[17]之上，该框架使用图形符号对编程语言的名称绑定规则进行编码。
				- 与作用域图一样，程序中的每个名称绑定都由相应图中的路径表示。
				- 与作用域图不同，我们的寻路算法维护一个挂起查询堆栈(因此得名)，允许名称绑定依赖于其他中间名称绑定的结果。
			- 堆栈图是文件增量的，这意味着源程序中的每个文件都由一个不相交的子图表示，它们之间没有边交叉。(在查询时创建特殊的虚拟边，以便在文件之间交叉。)
			- 我们可以单独构造每个文件的子图，而无需检查程序中的任何其他文件。
				- 这让我们可以很容易地检测和重用我们已经看到和分析过的文件版本的结果。
				- 由于项目历史中的大多数提交更改了项目中的一小部分文件，因此这大大降低了提供此服务的计算和存储成本。
	- 背景和历史视角
		- 我们从2017年开始研究如何最好地将代码导航功能添加到GitHub。
		- 代码导航在本地编辑器中广泛可用，因此一个吸引人的可能方法是采用任何支持本地编辑器解决方案的技术，并在必要时将其移植到我们的生产网页服务器环境中运行。
		- 然而，与软件工厂相比，本地编辑器中的代码导航体验有明显的不同。
			- 与本地编辑器不同，在本地编辑器中，只有单个用户查看单个项目(主要是单个项目代码的当前版本)并与之交互，软件锻造必须支持无限数量的用户同时查看锻造上托管的任何代码的任何历史版本。此外，除了那些编写和维护代码的用户外，我们还必须支持那些正在探索和浏览代码的用户。这些探索者经常在代码编写几个月或几年之后查看代码。这意味着我们必须保持代码导航数据的可用性，并且可以随时查询;或者确保我们可以(快速)根据需求重新生成数据，以响应未来的用户查询。这导致了索引时间、用户使用时的明显区别
		- 将程序或库的新快照“推送”到锻造，以及查询时间，当(可能是不同的)用户希望在将来的某个时间点查看或探索该快照时。
		-