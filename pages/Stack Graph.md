- **Tags**: [[Code Intelligence]] [[Code Navigation]] [[tree-sitter]]
-
- 相关的文章、论文
	- https://github.blog/2021-12-09-introducing-stack-graphs/
		- 一篇介绍
	- https://dcreager.net/talks/stack-graphs/
		- 会议分享video
	- https://media.dcreager.net/dcreager-2022-ucsc-lsd-slides.pdf
		- 会议分享video相关的PPT
	- https://github.com/github/stack-graphs
		- 相关源码
	- https://news.ycombinator.com/item?id=29500602
		- 作者在黑客论坛上的讨论
	- https://arxiv.org/pdf/2211.01224.pdf
		- 相关发表的论文
	- https://github.github.io/stack-graph-docs/
		- 内部文档
-
- Stack graphs（Name resolution at scale）
	- 来源：
		- https://arxiv.org/pdf/2211.01224.pdf
	- abstact
		- 我们提出了堆栈图，这是Visser等人的范围图框架的扩展。堆栈图支持GitHub的精确代码导航，允许用户在存储库内部和跨存储库导航名称绑定引用。与作用域图一样，堆栈图在图结构中编码有关程序的名称绑定信息，其中路径表示有效的名称绑定。然后通过简单的寻路搜索实现对其定义的引用解析。
		- GitHub拥有数百万个存储库，包含总代码数pb，以数百种不同的编程语言实现，每分钟接收数千次推送。
			- 为了支持这种规模，我们确保图的构造和寻路判断是文件增量的:
				- 对于每个源文件，我们创建一个孤立的子图，而不需要了解程序中的任何其他文件，也不需要看到程序中的任何其他文件。
				- 这让我们消除了重新分析我们已经看到的文件版本的存储和计算成本。
				- 由于大多数提交只更改存储库中文件的一小部分，因此这大大降低了为大型、频繁更改的存储库建立索引的操作成本。
		- 为了处理面向类型的名称查找(需要“暂停”当前查找以解析另一个名称)，我们的名称解析算法维护当前暂停(但仍然挂起)查找的堆栈。
		- 堆栈图可以通过对程序源代码的纯语法分析来构建，使用一种新的声明式图构建语言。
			- 这意味着我们可以为每个存储库提取名称绑定信息，而无需任何包配置，也无需调用任意的、不受信任的、特定于包的构建过程。
	- 1. Introduction
		- 代码编辑器长期以来一直提供诸如代码导航之类的生产力特性，它允许用户查看和导航代码中的结构关系，特别是代码中的名称所引用的实体。
		- 这些特性在像GitHub这样的软件工厂平台上同样有用。
		- 然而，大型软件工厂必须在多个方向上支持完全不同数量级的规模：
			- 存储代码的总量;
			- 一段时间内收到的更改数量;
			- 需要查询历史版本的代码;
			- 同时进行查询的用户数量;
			- 以及支持的编程语言的数量。
		- 我们已经开发了堆栈图来解决这些限制。
			- 堆栈图建立在Visser等人的作用域图框架[17]之上，该框架使用图形符号对编程语言的名称绑定规则进行编码。
				- 与作用域图一样，程序中的每个名称绑定都由相应图中的路径表示。
				- 与作用域图不同，我们的寻路算法维护一个挂起查询堆栈(因此得名)，允许名称绑定依赖于其他中间名称绑定的结果。
			- 堆栈图是文件增量的，这意味着源程序中的每个文件都由一个不相交的子图表示，它们之间没有边交叉。(在查询时创建特殊的虚拟边，以便在文件之间交叉。)
			- 我们可以单独构造每个文件的子图，而无需检查程序中的任何其他文件。
				- 这让我们可以很容易地检测和重用我们已经看到和分析过的文件版本的结果。
				- 由于项目历史中的大多数提交更改了项目中的一小部分文件，因此这大大降低了提供此服务的计算和存储成本。
	- 2. 背景和历史视角
		- 我们从2017年开始研究如何最好地将代码导航功能添加到GitHub。
		- 代码导航在本地编辑器中广泛可用，因此一个吸引人的可能方法是采用任何支持本地编辑器解决方案的技术，并在必要时将其移植到我们的生产网页服务器环境中运行。
			- 然而，与软件工厂（指Github）相比，本地编辑器中的代码导航体验有明显的不同。
				- 与本地编辑器不同，在本地编辑器中，只有单个用户查看单个项目(主要是单个项目代码的当前版本)并与之交互，软件工厂必须支持无限数量的用户同时查看锻造上托管的任何代码的任何历史版本。
				- 此外，除了那些编写和维护代码的用户外，我们还必须支持那些正在探索和浏览代码的用户。
					- 这些探索者经常在代码编写几个月或几年之后查看代码。
					- 这意味着我们必须保持代码导航数据的可用性，并且可以随时查询;或者确保我们可以(快速)根据需求重新生成数据，以响应未来的用户查询。
					- 这导致索引时间与查询时间之间有一个明确的区别，
						- 索引时间是用户将程序或库的新快照“推送”到锻造站的时间，
						- 查询时间是（可能不同的）用户在未来某个时点想要查看或探索那个快照的时间。
		- 我们对索引和查询阶段有着雄心勃勃但冲突的延迟目标。
			- 我们最重要的目标是最小化用户执行代码导航查询和我们在他们的浏览器中显示查询结果之间的延迟[9]。为了实现这一目标，我们必须在索引时间预先计算一些信息。
			- 也就是说，我们不想做过多的预计算工作，以便在每次推送后快速提供代码导航，并且我们不会浪费时间预计算从未被查看的存储库或提交的代码导航数据。
		- 我们的规模也带来了独特的挑战。最明显的是代码的体量：GitHub保存了数PB的代码历史，并且每分钟都接收到数千个新的代码快照。
			- 我们的框架必须是增量的，跳过重新分析我们已经看过的代码的成本，这是至关重要的。
			- 幸运的是，每个项目的历史大部分是冗余的，大多数提交只改变了一小部分文件。
				- 因此，我们特别倾向于文件增量分析，我们可以在索引时间独立分析每个源文件，而无需检查（或访问）项目中的其他文件。
				- [[git]]使用的Merkle树[7]数据模型为每个文件版本提供了一个独特的blob标识符，这只取决于文件的内容。
					- 因为文件的标识符在分析开始之前就可用，我们可以跳过冗余的文件增量工作的存储和计算成本。
		- 最后，GitHub托管了大量编程语言编写的代码。我们希望所有这些语言都能进行代码导航。
			- 对于较少流行语言的长尾支持，GitHub工程师永远不会有成本效益的实施方法。
			- 但必须有一条路径供某人（无论是GitHub工程师还是外部语言社区的成员）为所有存在并正在使用的编程语言添加支持。
		- 正如我们在第5部分详述的，现有的本地编辑器代码导航解决方案不能满足这些限制。在研究现有的学术工作是否能帮助解决这个问题时，我们发现了作用域图([[Scope Graph]])框架[17]，它引入了一种新颖且直观的方法，用图结构编码编程语言的名称绑定语义。
			- 这似乎可能满足我们的语言支持目标：所有特定于语言的逻辑都将隔离到图构建过程中，所有查询都会通过一个在该图结构上操作的独立于语言的算法进行。
			- 然而，我们很快发现，按照最初的描述，作用域图无法满足我们的规模要求。在本节的其余部分，我们将使用一个简单的Python程序作为运行示例，探讨原因。
	- 2.1 Néron scope graphs
		- ![image.png](../assets/image_1695543639513_0.png)
		- 圆形节点表示作用域，
		- 矩形节点表示定义和引用
		- 边（Edge）将作用域连接到该作用域中定义的每个符号，并将每个引用连接到应该解析该符号的作用域。
		- 一些说明
			- 作用域R是一个根节点，代表所有Python模块所属的全局命名空间
			- 而a1和b4是在两个文件中定义的模块的定义。
			- 作用域20包含类A的类成员，而从20到x3的边表明x是这些类成员之一。
			- 作用域50代表通过成员访问运算符在第一个print声明中可用的名称
			- 而从x9到50的边表明引用必须相对于这些名称进行解析。
		- 一些说明
			- 作用域之间的边表示嵌套。
				- 例如，Python模块中的顶级定义是顺序评估的，每个名称只在其定义被评估后才可见。
					- 这通过连接作用域30、31和32的边进行建模，这些作用域分别代表在import语句、类定义和第一个print语句之后立即可见的名称。
				- 作用域40包含类B的类成员；它和30之间的边模型了类体内的引用如何可以引用包含词法作用域中的定义。
			- 开放箭头边代表“导入”，使命名作用域的内容在其他地方可用。
				- 例如，40和A7之间的边指定B继承了A的所有类成员，而A2和20之间的边指定作用域20包含类A的类成员。
		- 一些说明
			- 我们还展示了正确解析引用x9到其定义x3的名称绑定路径。
				- 这需要通过导入边解析几个中间引用：
					- 解析B8到类B的定义；
					- A7到其超类；
					- a5到定义该超类的模块。
		- 重要的是，Néron作用域图可以根据每个文件的阴影部分划分为不相交的子图。
			- 除了根节点（这是一个跨所有文件共享的单个节点），每个节点都属于某个文件的子图。
			- 每条边都连接两个属于同一文件的节点，或者连接一个节点到共享的根节点。
			- 在**查询**时，我们必须将作用域图作为一个整体来考虑，因为名称绑定路径可以从一个子图跨到另一个子图。
			- 然而，我们可以在**索引**时间构建每个文件的子图，而无需考虑程序中任何其他文件的内容。因此，Néron作用域图的构建正好以我们需要的方式进行**文件增量**。
			-
		-
		-